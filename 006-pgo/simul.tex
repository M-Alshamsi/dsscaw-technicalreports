\chapter{Simulation}
\label{chap:simul}
I'd love to be able to ask questions like, ``how often does team A win against
  team B when team A subs out their lead?''
  and ``how does burning both shields on the lead affect chances of victory?''
I'd like to be able to take two teams, and walk the game tree, seeing how
  each decision shapes future possible outcomes: ``There are 80 billion
  possible games from this point. If decision D is made, Team A
  wins 60\% of the remaining 60 billion. If decision E is made instead,
  Team A wins 80\% of the remaining 20 billion.'' Etc.

It is unlikely that simple closed form solutions exist describing
 the set of reasonable games between two arbitrary opponents (see \autoref{chap:unbounded}),
 let alone two teams.
For the highest level of predictive power, we must turn to machine-aided simulation.
Here we are lucky, for unlike most contests, Pokémon GO is concretely finite and discrete.
Its time evolves in half-second turns, each of which presents a small number of choices
  to both Trainers.
The use of random numbers is minimal.
Finally, it never diverges, instead advancing always towards a conclusion\footnote{There
  is an exception to convergence: both Trainers continuously choosing to do nothing (remember,
  even zero power attacks do one point of damage). This is pathological, and we
  simply dismiss all choice-pairs that change no state beyond the clock, neatly sidestepping this issue.
  Even if we didn't, there's a time limit on matches.}.
We thus needn't reject exhaustive simulation out of hand.
A naive but still viable solution is to begin at the first turn, generate the set
  of possible choices for both Trainers, and recurse on each one, performing
  a depth-first generation of the game tree.
When done, we'll know how each choice affects the universe of possible outcomes,
  and how the teams ought fare for random choices.

Let's examine the computational requirements.
What choices are available on a given turn?
If either Trainer has no Pokémon remaining, the match is over, and no choice
  need be made---we have our result, and can begin rolling up our recursion.
A Trainer otherwise has between one and three Pokémon, one of which is active
  in the arena.
If the active Pokémon is in the middle of a multiturn fast attack, the
  Trainer has no choice to make.
Otherwise, if more than one Pokémon is present, and the substitution timer is
  inactive, the Trainer may call for a substitution.
If there is sufficient energy, the Trainer may call for a charged attack.
In the case of a charged attack, the defending Trainer can opt to use a Defense
  Shield (if any remain).
The Trainer can call for a fast attack, or do nothing for the turn.
Each option must be pursued for an exhaustive search.

In the best case, no choices are available, and the turn is handled in constant
  time and space.
In the worst case, each Trainer has four options, for a Cartesian product
  of sixteen choicepairs---we blow up to 4 billion states in eight turns,
  and will not be going to space today.
The growth is clearly exponential, and continuous realization of either the
  best or worst case is vanishingly rare.
There will most often be two or three available choices for each Trainer,
  for a product of about eight.
Nonetheless, we require $16^n$ time and space for $n$ turns in the worse case.
It's time to prune this game tree.

For each state, we must preserve the HP and energy of six Pokémon,
  the attack and defense buff level for two Pokémon,
  the number of turns remaining in two ongoing fast attacks,
  the number of shields remaining for each Trainer,
  and the turns remaining on each Trainer's substitution timer.
These changes are infrequent, so rather than duplicating the stats in
  each state, it might be wise to store the sets of stats externally,
  and index into them from the states.
In many matches, there will be no such changes, and we'll require
  only constant state.

\section{Closed form of the endgame}
Game simulation is friendly to the technique of memoization, i.e.\ storing
  and recognizing equivalent game states.
The easiest place to apply this is the endgame.
More correctly, this is the easiest way to choose states to memoize,
  such that we can effectively look them up and don't blow up memory.
Even better would be a closed form analytic treatment of the endgame,
  which seems like it ought be possible.
Let's restrict ourselves to the case of one Pokémon remaining per Trainer.
We dispense with charged attacks entirely (at least initially) by considering
  only those states where the possible turns remaining times EPT plus current
  energy is less than the energy required for a charged attack.
This restriction means we can ignore shields, as they're only relevant
  when charged attacks are used.
We will call these subgraphs ``death marches''.

How do we put an upper bound on turns?
Remember that we don't consider rounds which effect no change in state.
There are thus five possible choice-pairs:
  \{ ongoing, ongoing \},
  \{ ongoing, noop \},
  \{ noop, ongoing \},
  \{ ongoing, fast \},
  \{ fast, ongoing \}.
The ``worst'' case (most turns) would take the form of two Pokémon
  with roughly equal HP taking turns executing fast attacks
  inflicting equal damage.
This is bounded by $T_{max}$ turns.

\[ T_{max} = \lceil\frac{HP_1}{D_2 * T_2}\rceil + \lceil\frac{HP_2}{D_1 * T_1}\rceil \]

$D$ is the damage inflicted per fast attack, and $T$ is the number of turns per fast attack.
This equation is well-defined for all attacks, since damage (unlike power,
  which can be zero) is always at least 1.
So, knowing $T_{max}$, we can determine those cases where no charged attack
  can be used: whenever $T_{max} * EPT + E_{current} < E_{charged}$ for both Pokémon.
In this case, we can easily construct a closed form for the number of wins
  possible for each Trainer, and evaluate it in constant time, eliding
  a large tree of explicit (stateful) simulation.
The outputs ought be the same as our general problem: the number of paths
  concluding in a victory for Trainer 1, the number concluding in victory for
  Trainer 2, and the number concluding in a tie\footnote{In the realized world,
  such a death march will usually see both Trainers spamming their fast attack,
  and a given context will always result in the same winner. We need account
  for all paths so the math works for overall analysis.}.
We ought be able to check this closed form with our simulation infrastructure,
  since recognizing and calculating the form adds complexity to
  already necessary code.

A tie requires that both Pokémon are reduced to 0 HP on the same turn.
This is the set of paths where each Pokémon launches exactly $\lceil\frac{HP}{D}\rceil$
  attacks, and the final damages are inflicted on the same turn.
Otherwise, all paths where a Trainer inflicts $\lceil\frac{HP}{D}\rceil$ fast attacks
  represent a victory for that Trainer.
We enter the death march state with neither, one, or both remaining Pokémon having
  turns outstanding on their fast attack.
Call these turns remaining $T_1$ and $T_2$, and the HP remaining $H_1$ and $H_2$.
Call the turns required by the fast attacks $FT_1$ and $FT_2$.
Call the damage inflicted $D_1$ and $D_2$.
Given our restriction on null states, all turns must see at least one Pokémon engaged
  in a fast attack.
Pseudocode for simulating a death march is given in \autoref{list:deathmarch}; it
  makes it obvious that all nodes will have either zero, two, or three children.

\begin{lstlisting}[caption={Death march simulation pseudocode},label={list:deathmarch}]
deathmarch (T1, T2, D1, D2, H1, H2)
               → {p1wins, p2wins, ties}
if T1 < T2
  if T1 > 0 // conclude p1's attack
    H2 -= D1
    if H2 <= 0
      return 1, 0, 0  // p1 wins
    T2 -= T1
    T1 = 0
  else // p1 wasn't doing anything
    --T2
else if T2 < T1
  if T2 > 0 // conclude p2's attack
    H1 -= D2
    if H1 <= 0
      return 0, 1, 0 // p2 wins
    T1 -= T2
    T2 = 0
  else // p2 wasn't doing anything
    --T1
else // they're equal
  if T1 // conclude both attacks
    H2 -= D1
    H1 -= D2
    if H2 <= 0 and H1 <= 0
      return 0, 0, 1 // tie
    else if H2 <= 0
      return 1, 0, 0 // p1 wins
    else if H1 <= 0
      return 0, 1, 0 // p2 wins
    T1 = T2 = 0
if T2 // p1 attacks or does nothing
    return deathmarch (FT1, T2, D1, D2, H1, H2) +
           deathmatch (0, T2, D1, D2, H1, H2)
else if T1 // p2 attacks or does nothing
    return deathmarch (T1, FT2, D1, D2, H1, H2) +
           deathmatch (T1, 0, D1, D2, H1, H2)
else // p1 attacks, p2 attacks, or both attack
    return deathmarch (FT1, 0, D1, D2, H1, H2) +
           deathmatch (0, FT2, D1, D2, H1, H2) +
           deathmatch (FT1, FT2, D1, D2, H1, H2)
\end{lstlisting}

\textbf{so construct it then...}
