\chapter{Simulation}
\label{chap:simul}
I'd love to be able to ask questions like, ``how often does team A win against
  team B when team A subs out their lead?''
  and ``how does burning both shields on the lead affect chances of victory?''
I'd like to be able to take two teams, and walk the game tree, seeing how
  each decision shapes future possible outcomes: ``There are 80 billion
  possible games from this point. If decision D is made, Team A
  wins 60\% of the remaining 60 billion. If decision E is made instead,
  Team A wins 80\% of the remaining 20 billion.'' Etc.

It is unlikely that simple closed form solutions exist describing
 the set of reasonable games between two arbitrary opponents (see \autoref{chap:unbounded}),
 let alone two teams.
For the highest level of predictive power, we must turn to machine-aided simulation.
Here we are lucky, for unlike most contests, Pokémon GO is concretely finite and discrete.
Its time evolves in half-second turns, each of which presents a small number of choices
  to both Trainers.
The use of random numbers is minimal.
Finally, it never diverges, instead advancing always towards a conclusion\footnote{There
  is an exception to convergence: both Trainers continuously choosing to do nothing (remember,
  even zero power attacks do one point of damage). This is pathological, and we
  simply dismiss all choice-pairs that change no state beyond the clock, neatly sidestepping this issue.
  Even if we didn't, there's a time limit on matches.}.
We thus needn't reject exhaustive simulation out of hand.
A naive but still viable solution is to begin at the first turn, generate the set
  of possible choices for both Trainers, and recurse on each one, performing
  a depth-first generation of the game tree.
When done, we'll know how each choice affects the universe of possible outcomes,
  and how the teams ought fare for random choices.

Let's examine computational requirements.
What choices are available on a given turn?
If either Trainer has no Pokémon remaining, the match is over, and no choice
  need be made---we have our result, and can roll up our recursion.
A Trainer otherwise has between one and three Pokémon, one of which is active
  in the arena.
If the active Pokémon is in the middle of a multiturn fast attack, the
  Trainer has no choice to make.
Otherwise, if more than one Pokémon is present, and the substitution timer is
  inactive, the Trainer may call for a substitution.
If there is sufficient energy, the Trainer may call for a charged attack.
In the case of a charged attack, the defending Trainer can opt to use a shield (if any remain).
The Trainer can call for a fast attack, or do nothing for the turn.
Each option must be pursued for an exhaustive search.

In the best case, no choices are available, and the turn is handled in constant
  time and space.
In the worst case, each Trainer has four options, for a Cartesian product
  of sixteen choicepairs---we blow up to 4 billion states in eight turns,
  and will not be going to space today.
The growth is clearly exponential, and continuous realization of either the
  best or worst case is vanishingly rare.
There will most often be two or three available choices for each Trainer,
  for a product of about eight.
Nonetheless, we require $16^n$ time and space for $n$ turns in the worse case.
It's time to prune this game tree.

For each state, we must preserve the HP and energy of six Pokémon,
  the attack and defense buff level for two Pokémon,
  the number of turns remaining in two ongoing fast attacks,
  the number of shields remaining for each Trainer,
  and the turns remaining on each Trainer's substitution timer.
These changes are infrequent, so rather than duplicating the stats in
  each state, it might be wise to store the sets of stats externally,
  and index into them from the states.

\section{Closed form of the endgame}
Game simulation is friendly to memoization, i.e.\ storing and recognizing equivalent game states.
The easiest place to apply this is the endgame.
More correctly, this is the easiest way to choose states to memoize,
  such that we can efficiently look them up without blowing up memory.
Even better would be a closed form analytic treatment of the endgame,
  which seems like it ought be possible.
Let's restrict ourselves to the case of one Pokémon remaining per Trainer.
We dispense with charged attacks entirely (at least initially) by considering
  only those states where the possible turns remaining times EPT plus
  energy is less than the energy required for a charged attack.
This restriction means we can ignore shields, as they're only relevant
  when charged attacks are used.
We call these subgraphs ``death marches''.

How do we put an upper bound on turns?
Remember that we don't consider rounds which effect no change in state.
There are thus five possible choice-pairs:
  \{ ongoing, ongoing \},
  \{ ongoing, noop \},
  \{ noop, ongoing \},
  \{ ongoing, fast \},
  \{ fast, ongoing \}.
The ``worst'' case (most turns) would take the form of two Pokémon
  with roughly equal HP taking turns executing fast attacks
  inflicting equal damage.
This is bounded by $T_{max}$ turns.

\[ T_{max} = \left\lceil\frac{HP_1}{D_2 * T_2}\right\rceil + \left\lceil\frac{HP_2}{D_1 * T_1}\right\rceil \]

$D$ is the damage inflicted per fast attack, and $T$ is the number of turns per fast attack.
This equation is well-defined for all attacks, since damage (unlike power,
  which can be zero) is always at least 1.
So, knowing $T_{max}$, we can determine those cases where no charged attack
  can be used: whenever $T_{max} * EPT + E_{current} < E_{charged}$ for both Pokémon.
In this case, we can easily construct a closed form for the number of wins
  possible for each Trainer, and evaluate it in constant time, eliding
  a large tree of explicit (stateful) simulation.
The outputs ought be the same as our general problem: the number of paths
  concluding in a victory for Trainer 1, the number concluding in victory for
  Trainer 2, and the number concluding in a tie\footnote{In the realized world,
  such a death march will usually see both Trainers spamming their fast attack,
  and a given context will always result in the same winner. We need account
  for all paths so the math works for overall analysis.}.
We ought be able to check this closed form with our simulation infrastructure,
  since recognizing and calculating the form adds complexity to
  already necessary code.

A tie requires that both Pokémon are reduced to 0 HP on the same turn.
This is the set of paths where each Pokémon launches exactly $\lceil\frac{HP}{D}\rceil$
  attacks, and the final damages are inflicted on the same turn.
Otherwise, all paths where a Trainer inflicts $\lceil\frac{HP}{D}\rceil$ fast attacks
  represent a victory for that Trainer.
We enter the death march state with neither, one, or both remaining Pokémon having
  turns outstanding on their fast attack.
Call these turns remaining $T_1$ and $T_2$, and the HP remaining $H_1$ and $H_2$.
Call the turns required by the fast attacks $FT_1$ and $FT_2$.
Call the damage inflicted $D_1$ and $D_2$.
Given our restriction on null states, all turns must see at least one Pokémon engaged
  in a fast attack.
Pseudocode for simulating a death march is given in \autoref{list:deathmarch}; it
  makes it obvious that all nodes will have either zero, two, or three children.

\begin{lstlisting}[caption={Death march simulation pseudocode},label={list:deathmarch}]
deathmarch (T1, T2, D1, D2, H1, H2)
               → {p1wins, p2wins, ties}
if T1 < T2
  if T1 > 0 // conclude p1's attack
    H2 -= D1
    if H2 <= 0
      return 1, 0, 0  // p1 wins
    T2 -= T1
    T1 = 0
  else // p1 wasn't doing anything
    --T2
else if T2 < T1
  if T2 > 0 // conclude p2's attack
    H1 -= D2
    if H1 <= 0
      return 0, 1, 0 // p2 wins
    T1 -= T2
    T2 = 0
  else // p2 wasn't doing anything
    --T1
else // they're equal
  if T1 // conclude both attacks
    H2 -= D1
    H1 -= D2
    if H2 <= 0 and H1 <= 0
      return 0, 0, 1 // tie
    else if H2 <= 0
      return 1, 0, 0 // p1 wins
    else if H1 <= 0
      return 0, 1, 0 // p2 wins
    T1 = T2 = 0
if T2 // p1 attacks or does nothing
    return deathmarch (FT1, T2, D1, D2, H1, H2) +
           deathmatch (0, T2, D1, D2, H1, H2)
else if T1 // p2 attacks or does nothing
    return deathmarch (T1, FT2, D1, D2, H1, H2) +
           deathmatch (T1, 0, D1, D2, H1, H2)
else // p1 attacks, p2 attacks, or both attack
    return deathmarch (FT1, 0, D1, D2, H1, H2) +
           deathmatch (0, FT2, D1, D2, H1, H2) +
           deathmatch (FT1, FT2, D1, D2, H1, H2)
\end{lstlisting}

\textbf{FIXME so construct it then...}

\section{Simulating 1x1}
\label{sec:simul1x1}
It's not difficult to do an exhaustive simulation of a 1x1 contest,
 where substitution is not in play.
A naive implementation will blow up, but we make the problem manageable
 via one simple restriction: if there's no good reason to do nothing,
 the Pokémon must do something.
Given the timing advice provided in \autoref{chap:strategy}, we will permit
 a do-nothing turn if the opponent is in the middle of a fast attack.
This turns out to be the only time we need allow unforced waits.
\begin{itemize}
\item Wait, no shield: \texttt{MOVE\_WAIT}
\item Wait and shield: \texttt{MOVE\_WAIT\_SHIELD}
\end{itemize}
We can wait (per above) if the opponent has an ongoing fast attack.
We can otherwise always throw our own:
\begin{itemize}
\item Fast attack, no shield: \texttt{MOVE\_FAST}
\item Fast attack and shield: \texttt{MOVE\_FAST\_SHIELD}
\end{itemize}
With sufficient energy, one or both charged attacks enter the picture:
\begin{itemize}
\item Charged attack one, no shield: \texttt{MOVE\_CHARGED1}
\item Charged attack one and shield: \texttt{MOVE\_CHARGED1\_SHIELD}
\item Charged attack two, no shield: \texttt{MOVE\_CHARGED2}
\item Charged attack two and shield: \texttt{MOVE\_CHARGED2\_SHIELD}
\end{itemize}
Finally, assuming other Pokémon have not fainted and the cooldown period is not active,
 we can call in a substitution.
``One'' and ``two down'' here are taken modulo 3,
 i.e. if the third Pokémon is active, the first Pokémon is one down,
 and the second Pokémon is two down.
\begin{itemize}
\item Sub in Pokémon one down: \texttt{MOVE\_SUB1}
\item Sub in Pokémon two down: \texttt{MOVE\_SUB2}
\end{itemize}
\inputminted{cpp}{s/moves.h}
Define types for basic state.
\texttt{results} is shared across all nodes (and will need be protected should we go parallel).
State-dependent context in \texttt{simulstate} is duplicated each time we recurse.
Finally, we need a three-vector for each team pointing into our database of Pokémon and attacks.
These are readonly following initialization, and global.
\inputminted{cpp}{s/simul.h}
Now we'll need a function to determine which moves are viable for each Trainer on a given turn.
\texttt{sift\_choices()} sets bits of a mask high if they're allowed.
\inputminted{cpp}{s/sift.h}
Collection of possible moves is handled in the top half, which loops through the choice-pairs,
  filters invalid ones, then calls the bottom half on each.
Should we want to parallelize, this loop is an obvious target.
\inputminted{cpp}{s/top.h}
The bottom half implements a choice-pair, and reports whether
  any Pokémon have been knocked out.
\inputminted{cpp}{s/bottom.h}
On a knockout, the top half calls \texttt{handle\_ko()}.
This is the only function that actually records results, and its loops are opportunities for further parallelism.
Right now we're only handling a single Pokémon per team, but we
 go ahead and implement this so that it'll work properly
 with arbitrarily many Pokémon.
When a Pokémon goes down, three things can happen:
\begin{itemize}
  \item No more Pokémon: the match is over.
  \item One more Pokémon: it becomes active. Continue the simulation.
  \item Two more Pokémon: simulate both replacements.
\end{itemize}
\inputminted{cpp}{s/ko.h}
The presented code simulates all possible meaningful exchanges of two fully specified Pokémon, starting
  with full HP, two shields, and no energy.

\section{Simulating 3x3}
\label{sec:simul3x3}
Simulating a full Trainer Battle requires supporting three Pokémon per Trainer,
  simulating replacement paths when a Pokémon faints,
  and handling substitutions.
Substitutions are a greater threat to our complexity, since they can happen
  on any turn (unless there has been a recent substitution).
Handling replacement is easier: all we need do is amend our frontend to
  seed all three positions, and implement switchover.
\textbf{FIXME}
