% arara: xelatex: {shell: true}
% arara: biber
% arara: makeglossaries
% arara: xelatex: {shell: true}
% arara: xelatex: {shell: true}
\documentclass[letterpaper,10pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{newfloat}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage[font=small,labelfont=bf]{caption}
\usepackage{fancyhdr}
\usepackage{makecell}
\usepackage{wrapfig}
\usepackage{parskip}
\usepackage[section]{placeins}
\usepackage{epigraph}
%\usepackage{sourcecodepro}
\usepackage{fontspec}
\usepackage[toc,nonumberlist,xindy]{glossaries}
\usepackage{xelatexemoji}
\usepackage{relsize}
%\setmonofont[Scale=0.7]{Source Code Pro}
\setmonofont[Scale=0.8]{Unifont}
\defaultfontfeatures{Ligatures=TeX}
\usepackage[table]{xcolor}
\usepackage{xcolor}
\usepackage{pdfpages}
\usepackage[titletoc,title]{appendix}
\usepackage{minted}
\usepackage{xeCJK}
\usepackage{tipa}
\usepackage{csquotes}
\usepackage{polyglossia}
\usepackage{arabxetex}
\setmainlanguage{english}
\setotherlanguages{hebrew,french,bulgarian,russian}
\newfontfamily\cyrillicfont[Script=Cyrillic]{Noto Sans}
\newfontfamily\hebrewfont[Scale=0.8,Script=Hebrew]{Frank Ruehl CLM}
\definecolor{dsscawpurp}{HTML}{b079b0}
\definecolor{dsscawpurpcap}{HTML}{6c286c}
\usepackage[font={color=dsscawpurpcap},labelfont={sc}]{caption}
\usepackage[backend=biber,
date=iso,
seconds=true,
style=numeric,
bibencoding=utf8,
]{biblatex}

\tracinglostchars=2

\addbibresource{\jobname.bib}
\usemintedstyle{friendly}
\newenvironment{denseitemize}{
  \begin{itemize}
      \setlength{\itemsep}{0pt}
}{
  \end{itemize}
}
% An attractive 'C++'
\newcommand\CC{C\nolinebreak\hspace{-.05em}\raisebox{.4ex}{\relsize{-3}{\textbf{+}}}\nolinebreak\hspace{-.10em}\raisebox{.4ex}{\relsize{-3}{\textbf{+}}}\hspace{.2em}}

\pagestyle{fancy}
\rhead{
  \includegraphics[height=\fontcharht\font`\D,keepaspectratio=true]{../dsscaw-hdr.pdf}
  \textcolor{dsscawpurp}{DSSCAW Technical Report \#004}
}

\title{Hacking the Planet (with Notcurses)\\
A Guide to TUIs and Character Graphics
}
\author{Nick Black, Consulting Scientist\\
\texttt{nickblack@linux.com}
}

\makeglossaries
\setglossarypreamble{When possible, I have followed the definitions of
  RFC 2978\cite{rfc2978} and the Glossary of Unicode Terms\cite{unicodeglossary}.}
\loadglsentries{glossary}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\includepdf{media/cover.pdf}
%\date{Feb 14, 2020}
\maketitle
%\thispagestyle{fancy}
\date{}
\vspace{1in}
\begin{center}
\includegraphics[width=.75\linewidth]{htp-with-notcurses.png}
\end{center}
\thispagestyle{empty}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\clearpage
\pagenumbering{roman}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace*{1.25in}
\begin{figure}[!htb]
\centering
\includegraphics[width=1\linewidth]{media/ibm3270.jpg}
\caption[A programmer at her IBM 3270]{A programmer at her IBM 3270 2A. \textit{Source: Jonathan Schilling}.}
\end{figure}
\clearpage
\vspace*{1in}
\begin{center}
  \textit{For T.\ S.\ Eliot, il miglior fabbro.} \\
  \vspace{.25in}
  \textit{For Jeanette Martin, for exhortations to go H.A.M. \\
  \vspace{.25in}
  For Jim Greenlee, for speaking rigor to my programming.\\
  \vspace{.25in}
    For Prof.\ Hyesoon Kim, for introducing me to the glorious world
    inside the die.\\
  \vspace{.25in}
    For Prof.\ Richard Vuduc, for demonstrating serenity in brilliance, and kindness in dominance.\\}
  \vspace{1in}\ldots but mostly for Emily.
\end{center}
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents
%\vfill
%\begin{center}
%\includegraphics[width=1\linewidth]{media/widechars.png}
%\end{center}

%\cleardoublepage
%\phantomsection
\addcontentsline{toc}{section}{\listfigurename}
\listoffigures
\addcontentsline{toc}{section}{List of Listings}
\listoflistings
\addcontentsline{toc}{section}{\listtablename}
\listoftables
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Foreward}
Hacking the Planet with Notcurses:\\
A Guide to Character Graphics and TUIs.

Copyright © 2020 Nick Black.

ISBN: 9798620069491

This edition corresponds to version 1.2.3 of the Notcurses
library, released 2020-03-07.

Notcurses can be downloaded from
\url{https://github.com/dankamongmen/notcurses}.

This document can be downloaded
from~\url{https://nick-black.com/htp-notcurses.pdf}.

Licensed under the Apache License, Version 2.0 (the ``License''); you may not
use this document except in compliance with the License. You may obtain a copy
of the License at \url{http://www.apache.org/licenses/LICENSE-2.0}.

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an ``AS IS'' BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

The entirety of this work is Free Documentation, written for love and released
to instruct. You should not have been charged to download this document. If
you'd like to show thanks for my efforts, I encourage a donation to
the~\href{https://www.thefire.org/}{Foundation for Individual Rights in Education} (\url{https://www.thefire.org/}).

This work was prepared on a Debian Unstable workstation and an Arch Linux laptop,
using Vim, \XeLaTeX, and the GIMP.

Tetris © The Tetris Company, LLC.
\textit{Hackers (1995)} © United Artists Pictures.
\textit{House of Leaves (2000)} © Penguin Random House.
``Ruins with Rain'' © Mark Ferrari/Living Worlds.
``Final Fantasy'' © Square Enix Co Ltd.
``Super Mario Bros.''© Nintendo of America.
``Ninja Gaiden'' © Koei Tecmo America.
``Street Fighter II'' and ``Mega Man 2'' © Capcom of America.
Please don't sue me.

\subsection{¡Peligro!}

The code written for this book attempts to minimize use of vertical space
without eliding error checking (or crossing into the realms of the grotesque).
Error handling is a fundamental slog of C programming, one that
inevitably complicates reliable applications.

These listings cannot be considered examples of good general style\ldots but they \textit{do} get the job done.

Three irregular idioms show up frequently:

\begin{denseitemize}
\item{Use of |= to collect non-zero return values from each of a series of
      non-interdependent function calls.}
\item{Right-hand-side conditionals fed into |=, e.g. \texttt{r |= (printf("dank") < 0);}.}
\item{Extensive use of ||'s short-circuiting property.}
\end{denseitemize}

\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagenumbering{arabic}

\epigraph{Our fine arts were developed, their types and uses were established, in times
very different from the present, by men whose power of action upon things was
insignificant in comparison with ours. But the amazing growth of our
techniques, the adaptability and precision they have attained, the ideas and
habits they are creating, make it a certainty that profound changes are
impending in the ancient craft of the Beautiful.}{Paul Valéry}
\section{Introduction}

I implemented Notcurses in the winter of 2019 after having a few patches
rejected from NCURSES. The first commit was pushed 2019-11-16. It proved to
be seductive as hell, and it was only with difficulty that I tore myself away
following three months of hard work. I started writing this manuscript
2020-02-12, following the 1.1.8 release. By that time, Notcurses subsumed large
chunks of NCURSES, adding a great deal more. The project had three major goals:

\begin{denseitemize}
\item to provide NCURSES-like functionality with 24-bit color, safety in the
    presence of multithreading, and full Unicode support,
\item to reduce the amount of boilerplate code necessary for the UIs of my
    TUI applications, including \textit{growlight} and \textit{omphalos}, and
\item to portably facilitate the most vivid character graphics possible.
\end{denseitemize}

Many people asked how such a thing was useful. My usual response was that
numerous devices don't present a bitmap interface, that X11 GUIs run remotely
over SSH are effectively unusable, that plenty of machines don't have a GUI
environment installed, that there are obvious applications for large outdoor
displays, and that Sixel isn't well-supported across different
terminal emulators. It seems impossible in an age of gigatransistor graphics
cards, but the text environment still presents perceivably less latency
than most GUI toolkits. That I was able to remove thousands of lines
of NCURSES code from my applications was a nice side benefit.

In truth, the main reasons were that it was fun, and I wanted to see how far
I could push it.

As I write this, Notcurses is present in Arch's AUR, and is awaiting promotion
from the Debian Incoming queue. Written as a C core, it enjoys \CC, Python, and
Rust wrappers. I have submitted it as a backend to NEStopia and RetroArch, and
intend to integrate it into Mesa as an OpenGL backend. So long as one can live
with the limited resolution available when a screen is divided into rectangular
cells, it can handle any graphics thrown at it. I hope to see it displace
NCURSES as the go-to character graphics library for new applications (there is
little value in porting existing applications to Notcurses, since an unchanged
application wouldn't take advantage of its advanced features).

While the X/Open Curses specification is unlikely to ever go away (nor should
it, as a lowest-common-denominator interface to devices Notcurses is unlikely
to ever support), I believe Notcurses to present a superior and
implementation for modern TUI applications.

The console ain't dead! Hack on, hax0rs.

\vfill

\begin{flushright}
  \textit{---February 2020, Atlanta}
\end{flushright}

\cleardoublepage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\vfill
\begin{figure}
\centering
\includegraphics[width=.65\linewidth]{media/chunli-box-front.png}
\caption[An example render.]{A rendered scene from the ``chunli'' demo (see Chapter~\ref{sec:ncdemo}),
  using some of the advanced capabilities of Notcurses. The Chun-Li sprite has
  been loaded from a transparent PNG (Chapter~\ref{sec:libav}) atop boxes
  (Chapter~\ref{sec:boxes}) drawn using Unicode (Chapter~\ref{section:unicode})
  and linear interpolations (Chapter~\ref{sec:lerps}). Along the top is a
  menu (Chapter~\ref{sec:menus}) and an independent plane (Chapter~\ref{sec:planes});
  both can be controlled with mice (Chapter~\ref{sec:input}). In the center,
  the desktop can be seen through the transparent background of the terminal.}
\end{figure}
\vfill
\cleardoublepage

\section{Right, what's all this, then?}
\label{sec:start}
\epigraph{A terminal is at the end of an electric wire, a shell is the home of a turtle, tty is a strange abbreviation and a console is a kind of cabinet.}{Gilles Leblanc\cite{gillesSO}}
Character graphics, aka text mode, aka the display side of a terminal, is
visualization that works with fonts rather than a pixel framebuffer\footnote{``Contones'', as raster graphics are known to printers.}
or a vector canvas\footnote{Nothing keeps you from implementing character graphics
with pixels or vectors, of course.}. There is furthermore an expectation that
this font is a fixed-width one---that all rendered glyphs are integer multiples
of some narrowest non-trivial glyph.

Given the same display hardware,

\begin{denseitemize}
\item{Character graphics are usually strictly less powerful than pure raster graphics, and}
\item{their lower effective resolution typically implies lower bandwidth requirements.}
\end{denseitemize}

A TUI (text user interface) is a holistic model, view, and controller implemented
using character graphics. TUIs, like WIMP\footnote{Windows, icons, menus, pointers, a paradigm so pervasive that
the industry collectively treasures a Wiemarian\cite{thirdreich} memory of Xerox PARC's noble
engineers stabbed in the back by management (not unlike the Oatmeal-fostered\cite{fuckoatmeal}
myopia regarding Edison and Tesla. I'll take Thomas Alva over Matthew Inman any
day). It too often goes unmentioned that the Alto and Star were as unusable as they were visionary\cite{lightningdealers}.
This is of course still superior to Java, which isn't even visionary.} GUIs,
freely move the cursor around their rectilinear display, as opposed to
line-oriented CLIs and their ineluctable marches through the scrolling region.

Given the same interactive task,\footnote{These relations are not
fundamental, but emerge from the grim meathook realities of GUI toolkits.}

\begin{denseitemize}
\item{A TUI implementation is almost certainly a smaller memory and disk footprint than a GUI,}
\item{a good TUI implementation might introduce less latency, and}
\item{a properly-done TUI implementation can often be significantly more portable.}
\end{denseitemize}

Of course, it can also be a big pile of character graphics shit.

For over two decades, NCURSES (a free software implementation of the X/Open Curses\cite{cursesosi}
specification, plus extensions\cite{ncursesfaq}) has been a ubiquitous go-to for implementing
TUIs. Maintainter (and author, in large part) Thomas E.\ Dickey
exemplifies conservative and fastidious stewardship. Perfectly lovely TUIs can
be built using NCURSES (as seen in Figure~\ref{fig:ncurses-tuis}), but it \textit{does}
have its origins in the 8-bit era, and shows its age.

\begin{figure}[!hbtp]
  \centering
    \includegraphics[width=.4\linewidth]{media/tui-ncmpcpp.png}
    \hfill
    \includegraphics[width=.4\linewidth]{media/tui-omphalos.png}
    \caption[NCURSES TUIs: Ncmpcpp and Omphalos.]
    {\texttt{ncmpcpp}, a \CC application
      that has driven my Music Player Daemon since 2008 or so.
      \texttt{omphalos}, a C application
      written using NCURSES in its extended mode.}
  \label{fig:ncurses-tuis}
\end{figure}

\begin{figure}[!htb] \centering
    \includegraphics[width=.4\linewidth]{media/tui-mapscii.png}
    \hfill
    \includegraphics[width=.4\linewidth]{media/tui-growlight.png}
    \caption[Non-NCURSES TUIs: Mapscii and Growlight.]{\texttt{mapscii}, a
    node.js application, blew my mind when I first saw it. The high resolution
    is achieved by using Braille characters, trading away some color control.
    \texttt{growlight} began life as an NCURSES C program, but was ported to
    Notcurses in 2019.}
  \label{fig:notncurses-tuis}
\end{figure}

Implementing a TUI will usually require, at a minimum:
\begin{denseitemize}
\item{Receiving input from user devices, including keyboards and mice,}
\item{some manner of user configuration widgets (menus, etc.),}
\item{watching for some other event(s) from the system, and},
\item{juggling these various components without wastefully polling, nor
       introducing undue latency, and enforcing safe synchronized access to
       the graphics interface.}
\end{denseitemize}

Perhaps most terrifyingly, it will require user interface design. Notcurses
attempts to assist with this by providing numerous ready-made widgets.

This text has two goals:
\begin{denseitemize}
\item{To provide a firm footing for design and implementation of character
    graphics and TUIs, elucidating the dimensions of design, along with difficulties
    to avoid, and}
\item{to serve as ``narrative reference''\cite{newjournalism} for my Notcurses
      library, and as a starting place for newcomers.}
\end{denseitemize}

\begin{figure}[!htb]
\centering \includegraphics[width=.5\linewidth]{media/emacs-xerox.jpg}
  \caption{Put not your trust in hackers making a fetish of Xerox PARC.}
  \label{fig:xeroxemacs}
\end{figure}

Cell graphics are primarily the realm of \textit{terminals}, which for the
purposes of this book encompass any means by which input devices act to drive
some process generating glyph-based output to a display. This includes hardware
terminals (inputs integrated with displays, connected to a computer as a unit),
operating system consoles (text-mode interfaces operating with the graphics
engine directly connected to the terminal driver), terminal multiplexers (tools
like \texttt{screen}, \texttt{tmux}, and \texttt{mosh}, providing a
memory-persistent virtual terminal with which other terminals can interact),
and terminal emulators (applications which present a virtual terminal atop the
shared input and raster output methods of a graphical user environment).
There's some vagueness and variety involved with these terms.

At its heart, a terminal is a line discipline plus two buffers: an input buffer
to collect user-generated events (possibly from multiple devices), and an
output buffer to be processed and displayed. The buffers can be modeled as byte
streams, mutating the output at the time of their display (in contrast to e.g.\
a framebuffer, where the entirety of the screen is present at any given time).
The earliest terminals were electromechanical teletypes, reproducing their
input as line-based print on paper. These gave rise to ``dumb terminals''
(cathode-ray displays with a scrolling rectilinear output area). ``Smart
terminals'' followed, with the ability to move freely within their display
area, and also to extract and act upon ``control codes'' embedded in the output
stream. The text modes of the first video cards were designed around the
capabilities of these smart terminals. This brings us to the present, wherein
high-powered LED displays have their pixels summoned up and ordered into
formations suitable for the reconstruction of 1970s technology (a history of
terminals is presented in Appendix~\ref{sec:terminals}).

The machine on which I'm preparing this \LaTeX\ contains a
TU104 GPU consisting of over thirteen billion 12nm-process transistors,
rendering its output to a 3440x1440 (almost five megapixel) display. Deep
within its silicon heart remains a VGA 80x25 text mode engine\cite{vga}, inherited
largely unchanged from the EGA, the CGA, the IBM Monochrome Display Adapter\footnote{The
history of video display standards since 1981's MDA is a story of imprecision,
dashed hopes, and idle dreams. Good luck finding authoritative references
for anything beyond \texttt{int 10h} real mode operation prior to version 1.0
of the SuperVGA VESA BIOS Extension\cite{videostandards}, released 1989-10-01\cite{vesa}.},
and before that smart terminals\footnote{As early as 1971, the block-oriented
IBM 3277 Model 2 ``green screen'' shipped with 80x24.}.


I mainly use this modern marvel to drive terminal emulators of 80 columns.

\cleardoublepage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Using direct mode with standard I\/O}
\label{sec:direct}
\epigraph{Unscrew the locks from the doors!\\Unscrew the doors themselves from their jambs!}{Walt Whitman, \textit{Song of Myself}}
Many tools don't intend to be full-screen TUI applications, but instead
implement that purest of UNIX interfaces: newline-delimited text, oblivious
to screen geometry, capable of being fed as input to other, similar programs.
For such tools, the full Notcurses capabilities are neither necessary nor
desirable. These programs are typically non-interactive: humans might peruse
their outputs and prepare their inputs, but they effectively run as a batch
task.

 Such tools might still want to colorize and otherwise style their output, at
least when being output to a terminal. This can be accomplished using the
\texttt{ncdirect} subset of Notcurses, and is known as \textit{direct mode}. Direct
mode functionality should not usually be mixed with other Notcurses calls.
Unlike full Notcurses, there is no explicit rendering step in direct mode, and
it is intended to be mixed among other use of standard I/O. Essentially, direct
mode ``styles your \texttt{printf()}s.'' Similarly to full Notcurses, direct mode
requires a valid and correct terminfo database entry, supplied via either the
\texttt{termtype} parameter to \texttt{ncdirect\_init()} or the \texttt{TERM} environment
variable. It does \textit{not}, however, require any particular encoding or
other locale properties\cite{setlocale} (full Notcurses requires a
properly-configured ASCII or UTF-8 locale).

Enter direct mode via a call to \texttt{ncdirect\_init()} with a successful
return of a non-\texttt{NULL} pointer to \texttt{struct ncdirect}. It is
typical to invoke this function as \texttt{ncdirect\_init(NULL, stdout)}. In this case, the terminal type must be present in the
\texttt{TERM} environment variable (this should have been done by the
terminal). The buffering and blocking status of \texttt{fp} will not be
changed. \texttt{NULL} is returned for any number of possible errors.
Otherwise, the \texttt{struct ncdirect} is ready to go, and should be cleaned
up with \texttt{ncdirect\_stop()}.

\begin{listing}[!htb]
\begin{minted}{C}
// Initialize a direct-mode notcurses context on the connected terminal at 'fp'. 'fp' must be a tty. You'll usually
// want stdout. Direct mode supportes a limited subset of notcurses routines which directly affect 'fp', and neither
// supports nor requires notcurses_render(). This can be used to add color and styling to text in the standard
// output paradigm. Returns NULL on error, including any failure initializing terminfo.
struct ncdirect* ncdirect_init(const char* termtype, FILE* fp);

// Release 'nc' and any associated resources. 0 on success, non-0 on failure.
int ncdirect_stop(struct ncdirect* nc);
\end{minted}
\caption{Initializing and stopping directmode.}
\end{listing}

Between these two calls, inject stylizing control codes into the \texttt{FILE*} with
the \texttt{ncdirect} (the \texttt{stylebits} values are detailed in Chapter~\ref{sec:attribute}).
As detailed in Chapter~\ref{sec:channels}, the terminal has a ``default foreground color''
and ``default background color''. Return to these default colors with
\texttt{ncdirect\_fg\_default()} and \texttt{ncdirect\_bg\_default()}.

\begin{listing}[!htb]
\begin{minted}{C}
int ncdirect_bg_rgb8(struct ncdirect* n, unsigned r, unsigned g, unsigned b);
int ncdirect_fg_rgb8(struct ncdirect* n, unsigned r, unsigned g, unsigned b);
int ncdirect_fg(struct ncdirect* n, unsigned rgb);
int ncdirect_bg(struct ncdirect* n, unsigned rgb);
int ncdirect_styles_set(struct ncdirect* n, unsigned stylebits);
int ncdirect_styles_on(struct ncdirect* n, unsigned stylebits);
int ncdirect_styles_off(struct ncdirect* n, unsigned stylebits);
int ncdirect_clear(struct ncdirect* n);
int ncdirect_fg_default(struct ncdirect* n);
int ncdirect_bg_default(struct ncdirect* n);
\end{minted}
\caption{The \texttt{ncdirect} styling API.}
\end{listing}

Direct mode provides helpers for determining the terminal geometry.

\begin{listing}[!htb]
\begin{minted}{C}
int ncdirect_dim_x(const struct ncdirect* nc);
int ncdirect_dim_y(const struct ncdirect* nc);
\end{minted}
\caption{Geometry discovery with \texttt{ncdirect}.}
\end{listing}

Direct mode allows the cursor to be disabled, enabled, and moved in
two-dimensional space. Either \texttt{y} or \texttt{x} may be specified as -1
to maintain location on the associated axis. Attempting to move the cursor
beyond the screen is an error.

\begin{listing}[!htb]
\begin{minted}{C}
int ncdirect_cursor_move_yx(struct ncdirect* n, int y, int x);
int ncdirect_cursor_enable(struct ncdirect* nc);
int ncdirect_cursor_disable(struct ncdirect* nc);
\end{minted}
\caption{Cursor management with \texttt{ncdirect}.}
\end{listing}

\subsection{Example: presenting \textit{\textcolor{blue}{House} of Leaves}}
Mark Z. Danielewski's experimental 2000 novel \textit{\textcolor{blue}{House} of Leaves}\cite{danielewski2000house} prints each
instance of the word \textcolor{blue}{house} in blue, even when it is a subword:

\begin{figure}[!htb]
\centering \includegraphics[width=.5\linewidth]{house-blue.png}
\caption{An excerpt from page 123 of \textit{\textcolor{blue}{House} of Leaves}.}
\label{fig:houseofleaves}
\end{figure}

We can easily write code to reproduce this effect for standard input and output.
Listing~\ref{list:holformatter} works as expected (see
Figure~\ref{fig:houseout}), but there are a few things worth noting about its
code. First, observe how much of the logic is devoted to checking and
propagating errors! Perhaps contrary to common expectation, reliable
code---especially when that code's primary effect is to write to
stdout---generally needs to check the results of e.g. \texttt{printf()} (what
happens if we're redirected to a file, and the disk is full?). A language
making use of exceptions would reduce if not eliminate this nonsense.

\begin{listing}[!htb]
\inputminted[]{C}{code/hol-formatter.c}
\caption{\texttt{hol-formatter.c}, a streaming formatter.}
\label{list:holformatter}
\end{listing}

\begin{figure}[!htb]
\centering \includegraphics[width=.75\linewidth]{hol-formatted.png}
\caption[\texttt{hol-formatter} as run on OCRd input.]{\texttt{hol-formatter} as run on our input. We use \texttt{tesseract} for OCR, with solid results.}
\label{fig:houseout}
\end{figure}

So long as we're dealing with either ASCII or UTF-8 input, our simple, old-skool
\texttt{tolower(3)} is satisfactory \textit{for this problem}. The key
observation is that UTF-8 encoded text can be compared for equality by
a structure-oblivious~\texttt{memcmp(3)}, as of course can ASCII.
Unless we need to color e.g.~\textcolor{blue}{\texttt{ℏöûⓈᴇ}} (maybe we should,
maybe we shouldn't) this is safe, simple, and sufficient. If we \textit{do}
wish to collapse distinct but by some measure similar EGCs, we should normalize
input as prescribed by Unicode Standard Annex \#15\cite{annex15}.

We don't switch from blue to some other specified color, because we don't know
the background color of the terminal. Some people, possibly aliens, don't favor
a dark terminal background. If the terminal background were white, and we had
just used e.g. \texttt{ncdirect\_fg(n, 0xffffff)}, text following
``\textcolor{blue}{house}'' would be invisible.

One might observe that a user with a blue background will have invisible
``\textcolor{blue}{house}'' text. This is a real issue, one lacking a perfect
solution\footnote{Applying \texttt{NCSTYLE\_STANDOUT} might or might not help.}.
It is not generally possible to discover the RGB values of the default colors.
I suppose all one can do is rest easy, serene in the belief that white
backgrounds are one thing, but people with chromatic backgrounds deserve
whatever happens to them.

\subsection{Example: colorizing a dumb game}
Imagine we've written the simple guessing game in Listing~\ref{list:guessgame}.

\begin{listing}[!htb]
\inputminted[]{C}{code/hilostdio.c}
\caption{\texttt{hilostdio.c}, a simple guessing game.}
\label{list:guessgame}
\end{listing}

The correct approach for a player is binary search, and for an $N$-bit
\texttt{long}, we expect to guess the number in no more than $N$ tries. Let's
color the output to indicate how bad of a guess was offered. We'll use red for
low guesses, blue for high guesses, and break the 256 shades of each (assuming
the other two components to be fixed) uniformly across the $N$ levels of
logarithmic distance\footnote{This would be a good place to employ \gls{gamma correction}.}.
If we wanted to do this (see Listing~\ref{list:hilodirect}) without direct use of RGB color,
we'd either need accept fewer shades, or be forced to reprogram the palette.

\begin{listing}[!htb]
\inputminted[]{C}{code/hilodirect.c}
\caption{\texttt{hilodirect.c}, a colorized version of the guessing game.}
\label{list:hilodirect}
\end{listing}

Stepping through the orders of magnitude\footnote{\texttt{\_\_builtin\_clzl()}
is a compiler intrinsic for \textit{count leading zeroes}. Exhaustive methods
for fast clzl can be found in \cite{hackerdelight}. Demonstrating that
absolute value of the difference of leading zeroes is a $lg_{2}$ difference
is left as an exercise for the reader.}, we get the expected gradient
(Figure~\ref{fig:colorguess}). Were we to actually play, the response would
converge to a balanced, strong green as we approached the correct answer.

\begin{figure}[!htb]
\centering \includegraphics[width=.75\linewidth]{media/hilodirect.png}
\caption{Colorized output from~\texttt{hilodirect.c}.}
\label{fig:colorguess}
\end{figure}

\subsection{Advanced coëxistence with stdio}
It is most common to initialize Notcurses with \texttt{stdout}, whether in
direct mode or fullscreen mode. This isn't the only way to operate, though.
By opening the tty directly using \texttt{/dev/tty}\cite{tty4}, and providing
this \texttt{FILE*} to Notcurses, a program passing its standard output to
another process can make concurrent use of Notcurses on the display, in either
direct or fullscreen mode. This is how the \texttt{notcurses-pipe} program
works\footnote{See \url{https://github.com/dankamongmen/notcurses/issues/381}.}.

For programs that need to write to the terminal, but want to ``overlay'' some
Notcurses, fullscreen mode won't work (though the program could be run in an
\texttt{ncprocess} widget; see Chapter~\ref{sec:uiwidgets}). Direct mode, however, is
a possibility. I've not yet written the example\footnote{Send me patches! Or
I'll do it\ldots eventually \url{https://github.com/dankamongmen/notcurses/issues/382}.}, but it is possible to, for
instance, periodically acquire the current cursor position, move elsewhere on
the screen, update a HUD, and return to the departure position. Scrolling could
be addressed by retaining a copy of any obliterated output. This would suffer
a startup period of one screen, during which the area scrolled above the HUD
would be cleared. This could be avoided by aligning the HUD with the top of
the terminal.

\subsection{Use in multithreaded environments}
\label{sec:directthreads}
Direct mode calls reduce to a cached terminfo lookup and \texttt{fprint(3)}
calls on the provided \texttt{FILE*}. The former is read-only; all necessary
elements are acquired from terminfo at the time of context creation. The latter
has the same thread semantics as \texttt{fprintf(3)}: while it is \textit{safe}
for multiple threads to concurrently print to the same \texttt{FILE*}, there are
no guarantees of ordering or even atomicity. Given the existence of multibyte
UTF-8 output, let alone potentially lengthy escape sequences, it's thus practically
necessary that multiple threads working with the same \texttt{FILE*} work exclusively.

Multiple threads may freely call read-only functions such as \texttt{ncdirect\_fg()}.

\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Using fullscreen mode}
\label{sec:fullscreen}
\epigraph{This is how space begins, with words only, signs traced on the blank page. To describe space: to name it, to trace it, like those portolano-makers who saturated the coastlines with the names of harbours, the names of capes, the names of inlets, until in the end the land was only separated from the sea by a continuous ribbon of text. Is the aleph, that place in Borges from which the entire world is visible simultaneously, anything other than an alphabet?}{Georges Perec, \textit{Species of Spaces}}
From this chapter forward, we will be using the fullscreen mode of Notcurses,
opening up all of its capabilities. This comes at a cost: while fullscreen mode
is being used, it is not safe to use standard I/O in conjunction with the
terminal controlled by Notcurses. Doing so is likely to (at a minimum) corrupt
the screen. If \texttt{stdout} and \texttt{stderr} are attached to the same
terminal (as they usually are in an interactive session), and \texttt{stdout}
is provided to Notcurses, output to \texttt{stderr} will corrupt the display
just as thoroughly as output to \texttt{stdout}. If your fullscreen Notcurses
program intends to log to \texttt{stderr}, you should first ensure that that
it has been redirected or is otherwise going somewhere different than
\texttt{stdout}. Note that simply rerendering the output will \textit{not}
necessarily clean up corruption, even following \texttt{ncplane\_erase()}
operations, since Notcurses optimizes its rendering based on its concept of the
screen. A call to \texttt{notcurses\_refresh()} will be necessary to sync the
the physical screen to Notcurses's concept thereof.

It is possible for the screen to be corrupted by external agents. For this
reason, Ctrl+L is by tradition bound to screen redrawing. You should hook this
input up to \texttt{notcurses\_refresh()} unless you have good reasons not to
do so (this is not default behavior of Notcurses only because Notcurses does
not itself read input). It is sadly not possible for such corruption to be
efficiently and generally detected.

It is possible for the attached terminal to be resized, especially (but not
only) for terminal emulators in GUI windowing environments\footnote{This could
also happen when refitting a \texttt{screen} or \texttt{tmux} session.
Even on the Linux or FreeBSD console, this can happen due to a change in video
resolution.}. Notcurses can detect such events, and synthesizes
\texttt{NCKEY\_RESIZE} inputs in response to them. If the screen shrinks, the
excess data relative to the constant origin will no longer be displayed (i.e.
the material in the upper left will be retained). If the screen is enlarged,
any data uncovered will be displayed, and the new area will otherwise be empty.
Some widgets can intelligently resize themselves in the face of screen
geometry changes (see Chapter~\ref{sec:uiwidgets}).

Notcurses prepares a given terminal for fullscreen mode in \texttt{notcurses\_init()}

\begin{listing}[!htb]
\begin{minted}{C}
// Initialize a notcurses context on the connected terminal at 'fp'. 'fp' must
// be a tty. You'll usually want stdout. Returns NULL on error, including any
// failure initializing terminfo.
struct notcurses* notcurses_init(const notcurses_options* opts, FILE* fp);

// Destroy a notcurses instance, restoring the terminal to its original state.
int notcurses_stop(struct notcurses* nc);
\end{minted}
\caption{Initializing and stopping fullscreen mode.}
\end{listing}

Before calling \texttt{notcurses\_init()} (and usually as one of the first lines
of the program) it is necessary to set the current locale via the standard
library function \texttt{setlocale()}. A coverage of ANSI/ISO C locales is beyond
the scope of this text, but it is usually sufficient to call
\texttt{setlocale(LC\_ALL, "")}, relying on the user's configured \texttt{LANG}
environment variable. Notcurses only supports those locales using
US-ASCII or UTF-8 encodings (see Chapter~\ref{section:unicode} for more
information on character encodings), and its capabilities on US-ASCII
are \textit{severely} constrained. \texttt{notcurses\_init()} will return an
error for any other encoding (see Figure~\ref{fig:encodingfail}).

\begin{figure}[!htb]
\centering \includegraphics[width=.7\linewidth]{media/notcurses-init-fails.png}
\caption{Notcurses refusing to start due to an unsupported character encoding.}
\label{fig:encodingfail}
\end{figure}

By default (assuming the \texttt{enter\_ca\_mode} terminfo capability is expressed),
Notcurses attempts to enter the ``\gls{smcup}''. Using the alternate screen
implies:
\begin{denseitemize}
\item{The screen will be cleared upon entry,}
\item{Output will not be appended to the scrollback buffer, and}
\item{On exit, output will be cleared.}
\end{denseitemize}
Whether or not the original screen contents are restored is terminal-dependent
(if the \texttt{non\_rev\_rmcup} terminfo capability is defined, the original
contents will \textit{not} be restored). The alternate screen is generally
useful, but some users don't like it, so it's wise to expose this via a
configuration option. Disabling use of the alternate screen can be done via the
\texttt{notcurses\_options} field \texttt{inhibit\_alternate\_screen}.

Successful creation of a \texttt{struct notcurses} implies the existence of
a \texttt{struct ncplane}, the ``standard plane''\footnote{\texttt{ncplane}s,
discussed in depth in Chapter~\ref{ncplane}, are the fundamental drawing surfaces of Notcurses.}.
This standard plane cannot be destroyed without destroying the containing
Notcurses context, nor can it be moved or resized by the user. Its size always
matches Notcurses's concept of the terminal's screen size, and its origin
always corresponds precisely to the terminal's origin. Aside from these
restrictions, the standard plane is a drawable surface like any other
\texttt{ncplane}---it can be moved along the z-axis, written to with arbitrary
glyphs and styles, made transparent, etc.

Once you're done using a \texttt{struct notcurses}, it's important to destroy
it with \texttt{notcurses\_stop()}, even if your process exits abnormally. By
default, Notcurses registers signal handlers for most fatal signals. These
handlers will call \texttt{notcurses\_stop()} and then pass the signal to the
orginal actions. You can disable this with the \texttt{no\_quit\_sighandlers}
field of \texttt{notcurses\_options}, but there aren't very many good reasons
to do so.

\subsection{The \texttt{notcurses\_options} structure}
The first parameter to \texttt{notcurses\_init()} is a (possibly \texttt{NULL})
\texttt{notcurses\_options}. This structure has been defined such that the
default options are equivalent to a zero-initialized structure. Passing \texttt{NULL}
is thus equivalent to passing a zero-initialized \texttt{notcurses\_options}.
The fields therein include:
\begin{denseitemize}
\item{\texttt{const char* termtype}: The name of the terminfo database entry to
    use. If \texttt{NULL}, the value of the environment variable \texttt{TERM}
    is used. Failure to initialize the terminfo database will result in a
    \texttt{notcurses\_init()} failure.} A defined but invalid or suboptimal
    entry will result in garbage, missing output, poor performance, reduced
    colors, and unsightly weight gain.
\item{\texttt{bool inhibit\_alternate\_screen}: As noted above, this prevents
    Notcurses from making use of the alternate screen, even if the \texttt{enter\_ca\_mode}
    terminfo capability is defined. It's best to wire this up to a user-managed
    option. Not using the alternate screen can look weird upon return to the
    shell (see Figure~\ref{fig:altscreen}).

\begin{figure}[!htb]
\centering \includegraphics[width=.7\linewidth]{media/no-alternate-screen.png}
\caption[Inhibiting use of the alternate screen.]{\texttt{notcurses-demo} can be invoked with \texttt{-k} to avoid
  using the alternate screen. Here, we see its output left on the screen as
  we return to our shell.}
\label{fig:altscreen}
\end{figure}
  }
\item{\texttt{bool retain\_cursor}: Notcurses hides the cursor by default.
    Set this to keep the cursor visible (the cursor can be turned on and off
    at runtime with \texttt{notcurses\_cursor\_enable()} and
    \texttt{notcurses\_cursor\_disable()}).}
\item{\texttt{bool suppress\_banner}: At startup, Notcurses emits some
    diagnostics and/or warnings, including version information and details
    about the current terminal. At shutdown, it prints performance statistics.
    These outputs \textit{do not} go to the alternate screen. Set this
    field to disable these outputs, but be aware that doing so might hide
    important warnings (see Figure~\ref{fig:banner}).

    \begin{figure}[!htb]
      \centering \includegraphics[width=.7\linewidth]{media/notcurses-banner.png}
      \caption[Notcurses initialization warnings.]{Initializing Notcurses without 24-bit color support will
        generate a warning, hopefully provoking your users to set it up.}
      \label{fig:banner}
    \end{figure}
}
\item{\texttt{bool no\_quit\_sighandlers}, \texttt{bool no\_winch\_sighandler}:
    As noted above, Notcurses by default registers signal actions for the normally fatal
    \texttt{SIGABRT}, \texttt{SIGINT}, \texttt{SIGQUIT}, and \texttt{SIGSEGV}.
    These handlers will call \texttt{notcurses\_stop()} before propagating the
    signal to the original actions. This is usually desirable, as the screen
    will not otherwise be restored to its previous state. In addition, \texttt{SIGWINCH}
    is caught in order to generate \texttt{NCKEY\_RESIZE} inputs. If you
    disable these handlers, you'll almost certainly want to replace them with
    similar functionality.}
\item{\texttt{FILE* renderfp}: If not \texttt{NULL}, this designates a file
    handle open for writing. In addition to the terminal, each rendered scene
    will be written to this file. This is intended for debugging.}
\item{\texttt{int margin\_t}, \texttt{int margin\_r},\texttt{int margin\_b}, \texttt{int margin\_l}}:
    Margin requests on the top, right, bottom, and left, respectively, of
    the rendering area (see Figure~\ref{fig:margins}). These requests will be satisfied on a best-effort
    basis---requesting more margin than is actually available is not an error.
    There must always be at least one row and one column available. If the
    alternate screen is being used, the margin areas will be cleared. Otherwise,
    they will be left uncleared. The margins are recomputed on a resize.
\end{denseitemize}

\begin{figure}[!htb]
    \centering
    \includegraphics[width=.75\linewidth]{media/margins.png}
    \caption{Margins can be used around the rendering area.}
    \label{fig:margins}
\end{figure}

\subsection{Functions on \texttt{notcurses} objects}
\label{sec:notcursesfuncs}
Output is not written to this top-level \texttt{struct notcurses}---that's
done with \texttt{ncplane}s---but there are a number of functions
available for these objects. Acquiring an \texttt{ncplane} for output can be
done by grabbing a reference to the standard plane, or creating a new plane.
New planes are always inserted into the top of the z-axis. All user-created
planes can be destroyed in one call with \texttt{notcurses\_drop\_planes()} (note
that it is not necessary to call this prior to \texttt{notcurses\_stop()}; the
latter cleans up all resources associated with the context).

\begin{listing}[!htb]
\begin{minted}{C}
// Get a reference to the standard plane (one matching our current idea of the
// terminal size) for this terminal. The standard plane always exists, and its
// origin is always at the uppermost, leftmost cell of the terminal.
struct ncplane* notcurses_stdplane(struct notcurses* nc);
const struct ncplane* notcurses_stdplane_const(const struct notcurses* nc);

// notcurses_stdplane(), plus free bonus dimensions written to non-NULL y/x!
static inline struct ncplane* notcurses_stddim_yx(struct notcurses* nc, int* restrict y, int* restrict x){
  struct ncplane* s = notcurses_stdplane(nc); // can't fail
  ncplane_dim_yx(s, y, x); // accepts NULL
  return s;
}

// Return our current idea of the terminal dimensions in rows and cols.
static inline void notcurses_term_dim_yx(struct notcurses* n, int* restrict rows, int* restrict cols){
  ncplane_dim_yx(notcurses_stdplane(n), rows, cols);
}

// Create a new ncplane at the specified offset (relative to the standard plane)
// and the specified size. The number of rows and columns must both be positive.
// This plane is initially at the top of the z-buffer, as if ncplane_move_top()
// had been called on it. The void* 'opaque' can be retrieved (and reset) later.
struct ncplane* ncplane_new(struct notcurses* nc, int rows, int cols, int yoff, int xoff, void* opaque);

// Return the topmost ncplane, of which there is always at least one.
struct ncplane* notcurses_top(struct notcurses* n);

// Destroy any ncplanes other than the stdplane.
void notcurses_drop_planes(struct notcurses* nc);

// Retrieve the contents of the specified cell as last rendered. The EGC is returned, or NULL on error.
// This EGC must be free()d by the caller. The cell 'c' is not bound to a plane, and thus its gcluster
// value must not be used—use the return value only.
char* notcurses_at_yx(struct notcurses* nc, int yoff, int xoff, cell* c);
\end{minted}
\caption{Essential functions on \texttt{notcurses} objects.}
\end{listing}

Reading input is a per-context operation, performed with \texttt{notcurses}
objects. It is discussed in detail in Chapter~\ref{sec:input}. When reading
input, we might get the synthesized event \texttt{NCKEY\_RESIZE}\footnote{This
event is generated upon receipt of a \texttt{SIGWINCH} signal, SIGnifying WINdow
CHange.}. This indicates that the terminal has been resized, and we might want
to call \texttt{notcurses\_resize()} and get the new dimensions. As discussed
earlier, sometimes the display is externally corrupted. It's thus a good idea
to hook some UI event (usually Ctrl+L) to \texttt{notcurses\_refresh()}, which
redraws every cell on the display according to the internal Notcurses
framebuffer.

\begin{listing}[!htb]
\begin{minted}{C}
// Refresh our idea of the terminal's dimensions, reshaping the standard plane
// if necessary. References to ncplanes (and the egcpools underlying cells)
// remain valid following a resize, but the cursor might have changed position.
int notcurses_resize(struct notcurses* n, int* restrict y, int* restrict x);

// Refresh the physical screen to match what was last rendered (i.e., without
// reflecting any changes since the last call to notcurses_render()). This is
// primarily useful if the screen is externally corrupted.
int notcurses_refresh(struct notcurses* n);
\end{minted}
\caption{Dealing with external events.}
\end{listing}

Finally, \texttt{notcurses\_render()} synthesizes a terminal's worth of current
state out of all your virtual objects, schedules an optimized list of escape
sequences and encoded characters, and blits the result to the terminal. Only
through \texttt{notcurses\_render()} (and transitively through its callers) ought
your program write to the actual terminal, and only \texttt{notcurses\_render()}
has any bearing on what the user sees. Between calls, you are free to do whatever
you want in terms of moving, reordering, creating, writing upon, and destroying
planes. There will be no flicker or tearing; what you last rendered remains on
the screen. When you've got your stack how you want it, and only then, invoke
\texttt{notcurses\_render()}. It is an exclusive function---any concurrent use
of the same \texttt{struct notcurses} is undefined.

\begin{listing}[!htb]
\begin{minted}{C}
// Make the physical screen match the virtual screen. Changes made to the
// virtual screen (i.e. most other calls) will not be visible until after a
// successful call to notcurses_render().
int notcurses_render(struct notcurses* nc);
\end{minted}
\caption{Rendering syncs the physical display to our visual planes.}
\end{listing}

\subsection{Reading, rendering, rasterizing, and writing}
\label{sec:rendering}

Understanding how Notcurses translates its data structures into a terminal
display is critical for reasoning about your program in general, and particularly
relevant for maximizing performance.

During initialization of a terminal, unless \texttt{suppress\_banner} is supplied
in the \texttt{notcurses\_options}, \texttt{notcurses\_init()} will print some
diagnostics to stdout, and flush the output buffer. Notcurses maintains an
internal virtual framebuffer, containing the state of the terminal as believed
to exist\footnote{Do not confuse this with the standard plane. This framebuffer
reflects rendering and rasterizing, not the output API.}. It is initialized in
\texttt{notcurses\_init()} to an empty matrix of cells, each cell having the
default foreground and background.

What happens next depends on whether the ``alternate screen'' (as described
earlier) is employed. If so, the terminal will be immediately cleared.
Otherwise, the terminal will not be altered until the first call to
\texttt{notcurses\_render()}. That first call, however, will write to every
cell of the terminal, effectively clearing any existing output. The upshot is
that it is not possible to integrate preexisting data into your TUI, regardless
of whether the alternate screen is used. This reflects the impossibility of
portably discovering the state of the terminal.

Subsequent to the first call, Notcurses---having written them---has a concept
of the display's contents. From that point on, screen updates will write only
to changed (``damaged'') cells. When only parts of the screen have changed,
this saves a tremendous amount of work. On an 80x45 terminal, if only a 10x10
region of cells have changed, we reduce our bandwidth by about
95\%\footnote{10x10 is only 2.7\% of 80x45, but there is overhead due to moving
the cursor to the region, and then positioning the cursor at the end of each
line of the region.}. These savings are multiplicative:

\begin{denseitemize}
\item{Notcurses doesn't have to \texttt{write()} the data (memory copy).}
\item{The terminal doesn't have to \texttt{read()} the data (memory copy).}
\item{The terminal doesn't need to process the data (assorted work).}
\item{The terminal doesn't need to write to the display (memory copy).}
\end{denseitemize}

Whether a cell has been updated is decided at rasterization time. Writing to
that cell between calls to \texttt{notcurses\_render()} does not necessarily
mean the cell will be considered damaged when it comes time to write. If the
cell has been damaged, it will be emitted, and the virtual framebuffer internal
to Notcurses will be updated.

Solving for the desired state of the screen is \textit{rendering}, and this is
the first step of \texttt{notcurses\_render()}. Solving for the screen means
solving for the current state of every cell, given our ordered set of
\texttt{ncplane}s. Solving for a cell means determining the extended grapheme
cluster to be rendered, determining the attributes to be applied to that EGC,
and determining the colors in which it ought be displayed. The higher a plane
is on the z-axis, the more it can impact these solutions:

\begin{denseitemize}
\item{The EGC and attribute are determined by the first plane intersecting with
      the cell having a non-null EGC at the intersecting coordinate. If there is
    no such intersecting EGC, the EGC is null, and the attribute is
    \texttt{NCSTYLE\_NORMAL}.} Null EGCs are rendered as spaces (i.\ e.\ entirely
    background color).
\item{The foreground color is determined by the first instance of a
    \texttt{CELL\_ALPHA\_OPAQUE} foreground color, or an instance of the
    default foreground color, or an instance of a palette-indexed foreground
    color, as well as any \texttt{CELL\_ALPHA\_HIGHCONTRAST} or \texttt{CELL\_ALPHA\_BLEND}
    foreground colors encountered along the way. If there is no such intersecting
    terminator, the foreground color is the color as calculated thus far. It is
    not possible to exhaust all intersecting planes without encountering some
    influence on the foreground color, since the standard plane intersects with
    all display cells. If \texttt{CELL\_ALPHA\_HIGHCONTRAST} is in play, the
    calculated color is then blended to stand out against the calculated background
    color.}
\item{The background color is determined in the same way as the foreground color,
    except without the complicating possibility of \texttt{CELL\_ALPHA\_HIGHCONTRAST}.}
\end{denseitemize}

Once a cell is solved, Notcurses needn't continue inspecting lower planes at
that coordinate. Once all cells are solved, rendering is complete, and any
planes left over can be skipped entirely. Until then, Notcurses steps down from
one plane to the next, starting at the topmost plane, and updates its solution
for any intersecting unsolved cells. It is thus generally more performant to
``hide'' planes at the bottom of the stack, ideally behind a large opaque plane,
rather than moving them beyond the boundaries of the visible window. Likewise,
planes ought be no larger than necessary, so that they intersect with the
minimum number of cells. Note that there will always be at least one plane
interacting with each visible coordinate, due to the properties of the default
plane. This process of filling a solutions matrix is referred to as rendering.

Having rendered the scene, \textit{rasterization} serializes a buffer to write
to the terminal, minimizing the amount of data by moving the cursor over undamaged
regions. This is the second step of \texttt{notcurses\_render()}. Writing this
data to the terminal as it's generated is a bad idea for several reasons: it can
provoke unnecessary context switches, it results in partially-updated displays,
and it definitely involves more system calls. Notcurses instead collects it in
one or more large allocations.

Proceeding cell-by-cell from the upper left to the lower right, Notcurses
compares the rendering solution set to its internal framebuffer. If a given row
is entirely undamaged, it can be skipped. Upon discovering the leftmost damage
on a row, an absolute cursor update is performed to the damaged cell. At each
damaged cell, the EGC will be emitted, along with any necessary styling
information. It is only necessary to emit styling escapes when they change, i.\ e.\ we
can emit multiple EGCs having the same style after only issuing the appropriate
escapes once. An RGB change takes about 14 bytes, a palette index change
takes about 6, and reverting to the default 2. For single-byte simple (ASCII)
EGCs, an RGB foreground and background represent 2800\% overhead per cell!
Eliding styling escapes is thus an important secondary optimization (it's of
course most desirable to not update the cell at all). Using the ``default
color'' as only one of the foreground or background requires emitting the
\texttt{op} escape followed by the appropriate escape for changing the fore- or
background (since \texttt{op} changes both at once).

Certain EGCs are understood to be all-foreground or all-background.
\texttt{U+2588 FULL BLOCK} is all foreground. \texttt{U+0020 SPACE} is all
background. When such characters are used, notcurses will emit whichever
character requires the fewest total bytes, taking into account both the
UTF-8 encoding length and the current color state.

The upshot is that holding styling constant across a horizontal stretch is
very desirable if that range's content is going to be changing. The most
pathological input to Notcurses is text that changes its foreground and background
on a cell-to-cell basis, especially when specified as RGB, that change from
render to render. Certain terminal emulators in particular respond to the
resulting deluge of RGB escapes very poorly (see Appendix~\ref{sec:termshade}).
As examples, see the \texttt{highcontrast} and \texttt{grid} demos of
\texttt{notcurses-demo}---a large \texttt{xterm} can be brought to its knees
by these routines.

Each subsequent range of undamaged cells on a line can be skipped over with
cursor movements, but as the skip length approaches 1, it becomes less and
less advantageous to do so. Rendering performance can be very roughly
categorized as inversely proportional to the product of:

\begin{denseitemize}
\item{color changes across the rendered screen,}
\item{planar depth before an opaque glyph and background are locked in,}
\item{number of UTF-8 bytes composing the rendered glyphs, and}
\item{screen geometry.}
\end{denseitemize}

With these buffers in hand, \texttt{notcurses\_render()} completes its task by
writing them to the terminal. This almost certainly means copying
them into a kernel buffer from which the terminal will then (following at
least one context switch and two system calls) read. Writing does not,
then, necessarily mean that the display has actually been updated, or even
that the terminal has read the data. If the terminal doesn't empty the buffer
quickly enough, however, you'll eventually run out of room and block. It is
thus critical to understand that \textbf{\texttt{notcurses\_render()} can block
for arbitrary amounts of time}\footnote{But see
\url{https://github.com/dankamongmen/notcurses/issues/214}.}. Furthermore,
if the terminal reads two renderings' worth of output at the same time, it is
likely to immediately enter the final state---you must not assume that a successful
\texttt{notcurses\_render()} is necessarily displayed within any arbitrary time,
or indeed that it corresponds with any displayed frame.

With those unhappy truths said, modern workstations ought have no problem pushing
notcurses onto commodity hardware at maximum framerates, with the terminal
faithfully reproducing each rendered scene. Even small microcontrollers ought
be able to render notcurses without user-perceptible latency. On a powerful
desktop with non-pathological output, it's easy to render in excess of
ten thousand frames per second, far beyond the refresh capabilities of any
existing monitor.

\subsection{Capabilities}
Different terminals expose different capabilities, and different means of
engaging them. These differences are encoded in the terminfo database\cite{terminfo}.
The Notcurses hides the differences where it can, and is built around those
capabilities which are most widely supported. Some applications, however, will
want to know details of the underlying implementation.
\begin{listing}[!htb]
\begin{minted}{C}
// Returns a 16-bit bitmask of supported curses-style attributes (NCSTYLE_UNDERLINE, NCSTYLE_BOLD,
// etc.). The attribute is only indicated as supported if the terminal can support it together
// with color. For more information, see the "ncv" capability in terminfo(5).
unsigned notcurses_supported_styles(const struct notcurses* nc);

// Returns the number of simultaneous colors claimed to be supported, or 1 if there is no color support.
// Note that several terminal emulators advertise more colors than they actually support, downsampling internally.
int notcurses_palette_size(const struct notcurses* nc);

// Can we fade? Fading requires either the "rgb" or "ccc" terminfo capability.
bool notcurses_canfade(const struct notcurses* nc);

// Can we set the "hardware" palette? Requires the "ccc" terminfo capability.
bool notcurses_canchangecolor(const struct notcurses* nc);

// Can we load images/videos? This requires being built against FFmpeg.
bool notcurses_canopen(const struct notcurses* nc);

// Get a human-readable string describing the running notcurses version.
const char* notcurses_version(void);
\end{minted}
\caption{The capabilities API.}
\end{listing}

\subsection{Statistics}
Notcurses tracks statistics across its operation, and a snapshot can be
acquired using the \texttt{notcurses\_stats()} function. This function cannot
fail. Most of the stats can be reset with \texttt{notcurses\_reset\_stats()}.
This function resets all cumulative stats, but not those which describe the
current state. Timings for renderings are across the breadth of
\texttt{notcurses\_render()}: they include all per-render preprocessing, output
generation, and dumping of the output (including any sleeping while blocked on
output to the terminal).

Statistics available include:
\begin{denseitemize}
\item{\texttt{renders}, \texttt{failed\_renders}: The number of successful and unsuccessful
    invocations of \texttt{notcurses\_render()}. Calls to \texttt{notcurses\_refresh()} do
    not show up in either of these stats. A render call can fail due to
    memory pressure, invalid EGCs, or a failure to successfully write to the
    output terminal.}
\item{\texttt{render\_bytes}: The number of bytes written in successful renders.
    Unsuccessful renders do not count towards the total. Dividing \texttt{renders}
  by \texttt{render\_bytes} yields the average bytes per (successful) render.}
\item{\texttt{render\_max\_bytes}, \texttt{render\_min\_bytes}: The maximum and
  minimum number of bytes emitted during a successful render.}
\item{\texttt{render\_ns}, \texttt{render\_min\_ns}, \texttt{render\_max\_ns}:
  The total, minimum, and maximum number of nanoseconds spent in \texttt{notcurses\_render()},
  whether the calls were successful or not. These timings are acquired using
  POSIX timers\cite{clockgettime} with the
  \texttt{CLOCK\_MONOTONIC}\footnote{Wouldn't \texttt{CLOCK\_MONOTONIC\_RAW} be
  superior? It would, where it's available, which isn't everywhere. It's also
  substantially more expensive than \texttt{CLOCK\_MONOTONIC} on Linux. Be
  aware, then, that NTP adjustments and time suspended \textit{do} show up in
  timings.} implementation.}
\item{\texttt{cellemissions}, \texttt{cellelisions}: The total number of EGCs
  written to output, and the number that did not need to be written due to
  being undamaged.}
\item{\texttt{fgemissions}, \texttt{fgelisions}: Foreground RGB values written to output, and the number elided.}
\item{\texttt{bgemissions}, \texttt{bgelisions}: Background RGB values written to output, and the number elided.}
\item{\texttt{defaultemissions}, \texttt{defaultelisions}: \texttt{op} escapes issued to set default colors, and the number elided.}
\item{\texttt{fbbytes}: The number of bytes devoted to framebuffers.}
\item{\texttt{planes}: The current number of planes. Will never drop below 1.}
\end{denseitemize}

\begin{listing}[!htb]
\begin{minted}{C}
typedef struct ncstats {
  // purely increasing (cumulative) stats
  uint64_t renders;          // number of successful notcurses_render() runs
  uint64_t failed_renders;   // number of aborted renders, should be 0
  uint64_t render_bytes;     // bytes emitted to ttyfp
  int64_t render_max_bytes;  // max bytes emitted for a frame
  int64_t render_min_bytes;  // min bytes emitted for a frame
  uint64_t render_ns;        // nanoseconds spent in notcurses_render()
  int64_t render_max_ns;     // max ns spent in notcurses_render()
  int64_t render_min_ns;     // min ns spent in successful notcurses_render()
  uint64_t cellelisions;     // cells we elided entirely thanks to damage maps
  uint64_t cellemissions;    // cells we emitted due to inferred damage
  uint64_t fgelisions;       // RGB fg elision count
  uint64_t fgemissions;      // RGB fg emissions
  uint64_t bgelisions;       // RGB bg elision count
  uint64_t bgemissions;      // RGB bg emissions
  uint64_t defaultelisions;  // default color was emitted
  uint64_t defaultemissions; // default color was elided
  // current state -- these can decrease
  uint64_t fbbytes;          // total bytes devoted to all active framebuffers
  unsigned planes;           // number of planes currently in existence
} ncstats;

// Acquire an atomic snapshot of the notcurses object's stats.
void notcurses_stats(struct notcurses* nc, ncstats* stats);

// Reset all cumulative stats (immediate ones, such as fbbytes, are not reset).
void notcurses_reset_stats(struct notcurses* nc, ncstats* stats);
\end{minted}
\caption{The statistics API.}
\end{listing}

\subsection{Use in multithreaded environments}
\label{sec:fullthreads}
To facilitate maximum performance, Notcurses does not perform any locking of
its own\footnote{This might change if Notcurses begins to actively acquire
input itself, necessary for certain desirable features. In that case, the
locking would only be present in the input layer.}. All functions are safe
for multiple threads to call with regards to system and standard library
resources. Things become more complex when multiple threads wish to ``write''
to Notcurses.

As mentioned above, it is necessary that \texttt{notcurses\_render()} calls
mutually exclude themselves, and also all other functions which mutate the
context. This includes all functions which write to a plane, functions which
change the ordering of planes (including deletion of a plane), and even
statistics functions. With very few exceptions, calling any Notcurses function
concurrently with \texttt{notcurses\_render()} is an error.

Beyond this ``big rendering lock'', functions ought not generally be called
concurrently on the same \texttt{ncplane}, unless all are reading. It is
unsafe, for instance, to call \texttt{ncplane\_putegc()} (a writing function)
concurrently with \texttt{ncplane\_cursor\_yx()} (a reading function). It
might not be obvious that functions such as \texttt{ncplane\_at\_yx()} which
write to a \texttt{cell} bound to the plane are writers, but supplying the
\texttt{cell} might require writing to the plane's egcpool, and thus they are
writers. In general, a function is only a reader if its \texttt{ncplane} argument
is \texttt{const}.

Concurrent operations on different planes are safe, unless they are changing
the ordering along the z-axis. Note that \texttt{ncplane\_destroy()} updates
the z-ordering by virtue of removing an element, and thus must not be called
along with e.g. \texttt{ncplane\_move\_top()}.

\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{simpleloop.tex}
\pagebreak
\cleardoublepage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{ttymechanics.tex}
\pagebreak
\cleardoublepage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Character encodings and glyphs}\label{section:unicode}
\label{sec:charsets}
\epigraph{Thou whorseon zed, thou unnecessary letter!}{Wiliam Shakespeare, \textit{King Lear}}
We'll be well-served by becoming familiar with our core building
blocks---character sets and their rasterized forms. Even if we were to shrink
the character cell to a single pixel, we'd still need write one or another
character into it, and emit a control code to stylize it\footnote{I've seen
this idea bandied about as if it's a serious suggestion. Besides the fact
that it won't work in a console, escapes are \textit{far} less efficient than
canvases or OpenGL display lists; if your plan involves using ANSI escape
sequences to drive a 1920x1080 display via roughly two million 1x1 character
cells, you're not going to space today, or maybe ever\cite{upgoerfive}.}.

In the beginning, there are somewhat Platonic \textit{characters}, one of the
most imprecise terms in all of computer science (even when we leave aside the
data type \texttt{char}). In and of itself, a character is nothing more than an
identifier: \texttt{LATIN CAPITAL LETTER I}\footnote{Isn't that a recursive
definition? You betcha.}. There are many things a character is not:

\begin{denseitemize}
\item{A character is not necessarily unique within a character set (see diacritic vs.\ precomposed forms).}
\item{Different characters needn't be distinct glyphs\cite{nothinggoesaway}.}
\item{A character needn't limit itself to a single column, even when using a fixed-width font.}
\item{A character does not necessarily have a visual representation.}
\item{A character does not necessarily have a single meaning among different languages.}
\item{In a given encoding, all characters are not necessarily the same size.}
\item{A character cannot necessarily capture the state of the keyboard at some time.}
\item{A character cannot necessarily describe a cell of a display at some time.}
\end{denseitemize}

Collecting characters and assigning them distinct (not necessarily contiguous or
even ordered) numbers creates a \textit{code set}, and the smallest contiguous
range of numbers covering this code set is a \textit{code space}. The Unicode 13
code space is comprised of 17 contiguous planes of 65,536 code points each, for
a size of $17*2^{16}$. It defines 143,859 characters, smaller than its
code space by an order of magnitude. A map from a code set to a set of bit
sequences is a \textit{character encoding}. There are numerous standard
encodings of the Universal Character Set, each of which represents the entire
set in different ways (the best one is UTF-8, as we will see). Character sets
are registered with IANA per RFC 2978\cite{rfc2978}, and character encodings
are registered with ISO Register of Coded Characters per ISO/IEC
2375\cite{iso2375}.

Character graphics are formed from \textit{glyphs}, the visual renderings of a
character encoding, supplied by a font. These glyphs might fuse into what
Unicode Standard Annex \#29\cite{annex29} refers to as a \textit{user-perceived
character} or \textit{grapheme cluster}. A formal algorithm for dividing a
stream of glyphs into grapheme clusters (``horizontally segmentable units of
text\cite{meaningcodepoints}'') achieves \textit{segmentation}. The current
Unicode segmentation algorithm yields \textit{extended grapheme clusters}.

These extended grapheme clusters (EGCs) can be thought of as the atoms of
character graphics. It is not generally possible to write them partially, nor
to partially overlay one atop another. Backspacing ought usually remove entire EGCs
at a time. The cursor ought cross an EGC in a single movement. In Notcurses,
each cell of a plane can hold a single EGC, which must be written as a single
unit. The actual number of columns occupied by an EGC is a property of the font
and layout engine being used.

In the modern era, Unicode is used just about everywhere, and programs must be
prepared to handle it. On the plus side, Unicode presents a single, coherent
means of representing all the world's languages, eliminating the old necessity
of switching among encodings at runtime. UNIX has its origins---and most of its
modern UI---in a much smaller character set: ASCII.

\subsection{Everyone loves ASCII}
\begin{wrapfigure}{O}{.5\textwidth}
  \fbox{%
    \parbox{0.5\textwidth}{
In the early 1960s, an IBM employee on a dare ate a hallucinogenic tapeworm
that pissed nitric acid. Stuffing his steaming, rapidly decoiling bowels
up into a brown paper bag, he was off to the hospital. Alas! On those very
hospital steps he was struck by lightning, and filled with spears, and
set upon by savage hogs, and finally exploded. The tapeworm emerged, clad
in shimmering mandorla, with a name pronounceable by no human tongue. ``Adding
hallucinogenic tapeworms to a late project only makes it later,'' cautioned Fred
Brooks\cite{mythicalman}, but Gene Amdahl knew no peace. ``This
Tapeworm Queen reminds me of halcyon Wisconsin days!'' he cried, and on a prototype
Model 30 appeared her Name. Struck by the power of that Name, all began to bow,
and to weep. She vomited forth the Tapeworm Gospel. Looking upon this filth, they
thought it Good.\\
So now you know what EBCDIC is. There ended up being no fewer than 57
variants\cite{searle} of EBCDIC, worthy of Heinz. We will speak of it no
further. If you find yourself needing more information about EBCDIC, think long
and hard about your life decisions.}%
  }
\end{wrapfigure}
The first digital codes were the English telegraph system of Charles Wheatstone
and William Cooke, and American Samuel Morse's code, with which he in 1837 famously
signaled ``What hath God wrought!'' The Morse system was simpler, running
over a single line, and quickly won out. The teleprinter of Jean-Maurice-Émile Baudot
(from whom we derive the modern unit \textit{baud}) followed in 1874, with its pentabit,
fixed-length Baudot code. Baudot code required 7.42 bittimes per character; at
a typical 0.022s bittime, it could transmit just over 6 characters per second\cite{martin}.

For our purposes, the story can reasonably start with a 7-bit encoding of
128 characters: ANSI X3.4-1986, perhaps better known as ASCII (Table~\ref{table:ascii}).
The first ASCII we would recognize as such\footnote{To paraphrase G.\ H.\
Hardy, ``ASCII-1963 was clever schoolboys; '68 a Fellow from another
College\cite{ghhardy}.''} was the unpublished ASCII-1965. The ASA (ANSI
before it was ANSI) ASCII 1963 didn't even have miniscules\footnote{Uppercase
and lowercase are loanwords from printing, where the two sets were
stored in different cases of the typesetting table. ``Majuscules'' and
``miniscules'' will mark your good breeding.}. ASCII-1968 was
released as USAS X3.4-1968 to wild acclaim. The ISO/IEC 646 standard\cite{iso646}
``internationalized'' ASCII-1968 by opening up 12 graphic characters to
regional specifications (the US ASCII defined the ``International Reference
Variant'')\cite{aivosto}.

The first 32 values are non-printable control codes, first given their current
definitions in ASCII 1968. These 32 codes (known as the ``C0'' coded control
set since ISO/IEC 646) lived on through ISO/IEC 2022 (ECMA-35), ISO/IEC 6429
(ECMA-48), ISO/IEC 8859 (ECMA-94), and are reproduced in today's ISO/IEC 10646,
aka the Universal Character Set. They're common across just about every
character set of which I'm aware (EBCDIC went almost entirely its own way,
because EBCDIC), despite being largely archaic and altogether mystifying. Most
of the associated semantics have been obsoleted, and in some cases the encoded
characters are now used for different purposes than originally planned (see
Table~\ref{table:c0maps}). These characters can be entered by pressing Ctrl
along with another key from ASCII; these combinations are defined using
``caret notation''.

\begin{table}[!htb]
  \centering
  \texttt{%
  \begin{tabular}{ |c||c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c| }
    \hline
    & x0 & x1 & x2 & x3 & x4 & x5 & x6 & x7 & x8 & x9 & xa & xb & xc & xd & xe & xf \\
    \hline
    \hline
    0x & NUL & SOH & STX & ETX & EOT & ENQ & ACK & BEL & BS & HT & LF & VT & FF & CR & SO & SI \\
    \hline
    1x & DLE & DC1 & DC2 & DC3 & DC4 & NAK & SYN & ETB & CAN & EM & SUB & ESC & FS & GS & RS & US \\
    \hline
    2x & SP & ! & " & \cellcolor{blue!25}\# & \cellcolor{blue!25}\$ & \% & \& & ' & ( & ) & * & + & , & - & . & / \\
    \hline
    3x & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & : & ; & < & = & > & ? \\
    \hline
    4x & \cellcolor{blue!25}@ & A & B & C & D & E & F & G & H & I & J & K & L & M & N & O \\
    \hline
    5x & P & Q & R & S & T & U & V & W & X & Y & Z & \cellcolor{blue!25}[ & \cellcolor{blue!25}\textbackslash{} & \cellcolor{blue!25}] & \cellcolor{blue!25}\^{} & \_ \\
    \hline
    6x & \cellcolor{blue!25}\textasciigrave{} & a & b & c & d & e & f & g & h & i & j & k & l & m & n & o \\
    \hline
    7x & p & q & r & s & t & u & v & w & x & y & z & \cellcolor{blue!25}\{ & \cellcolor{blue!25}| & \cellcolor{blue!25}\} & \cellcolor{blue!25}\textasciitilde{} & DEL \\
    \hline
  \end{tabular}
  }
  \caption[ANSI X3.4-1986 (ASCII)]{ANSI X3.4-1986 (ISO/IEC 646-IRV, IA5, T.50 IRA, RFC 20)---American Standard Code for Information Interchange. Shaded characters can be replaced in regional variants.}
  \label{table:ascii}
\end{table}

Recall the \texttt{struct termios} from Chapter~\ref{section:tty}. The \texttt{c\_cc}
array of that structure defines ``special characters'' for the terminal. Aside from
CR and LF, the various caret controls can there be recovered and redefined. Should
you really want to send \texttt{SIGINT} via 'a' rather than Ctrl+C, that's where
you can do it.

\begin{table}[!htb]
  \centering
  \begin{tabular}{ |c|c|c|p{.5\textwidth}| }
    \hline
    Character & Caret & C & Semantics \\
    \hline
    \hline
    0x00 (NUL) & \texttt{\^{}@} & & \\
    \hline
    0x03 (ETX) & \texttt{\^{}C} & & Deliver \texttt{SIGINT} \\
    \hline
    0x04 (EOT) & \texttt{\^{}D} & & Indicate end-of-file \\
    \hline
    0x07 (BEL) & \texttt{\^{}G} & \textbackslash{}a & Alert (bell) \\
    \hline
    0x08 (BS) & \texttt{\^{}H} & \textbackslash{}b & Backspace \\
    \hline
    0x09 (HT) & \texttt{\^{}I} & \textbackslash{}t & Proceed to next tab stop \\
    \hline
    0x0a (LF) & \texttt{\^{}J} & \textbackslash{}n & Move down one line \\
    \hline
    0x0b (VT) & \texttt{\^{}K} & \textbackslash{}v & Move down to next vertical tab \\
    \hline
    0x0c (CR) & \texttt{\^{}L} & \textbackslash{}f & Move to start of line \\
    \hline
    0x11 (DC1) & \texttt{\^{}Q} & & Software flow control (resume output) \\
    \hline
    0x13 (DC3) & \texttt{\^{}S} & & Software flow control (pause output) \\
    \hline
    0x1a (SUB) & \texttt{\^{}Z} & & Deliver \texttt{SIGSTOP} \\
    \hline
    0x1b (ESC) & \texttt{\^{}[} & & Initiate escape sequence \\
    \hline
    0x1c (FS) & \texttt{\^{}\textbackslash{}} & & Deliver \texttt{SIGQUIT} \\
    \hline
    0x1d (GS) & \texttt{\^{}]} & & \\
    \hline
    0x1e (RS) & \texttt{\^{}\^{}} & & \\
    \hline
    0x1f (US) & \texttt{\^{}\_} & & \\
    \hline
  \end{tabular}
  \caption[Usual UNIX semantics of C0]{Usual UNIX semantics of C0. The exact mappings can be inspected with \texttt{stty -a}.}
  \label{table:c0maps}
\end{table}

\subsection{Eight-bit character sets messily diverge}
\begin{wrapfigure}{o}{0.5\textwidth}
\centering
\includegraphics[width=0.5\textwidth]{media/charset-timeline.png}
\caption{Timeline of selected character sets.}
\label{fig:charset-timeline}
\end{wrapfigure}

US-ASCII and the regional dialects of ISO/IEC 646 were more or less sufficient
for working with English\footnote{As far as this author knows, ASCII
can faithfully represent only (modern) English, Latin, and Swahili.}, but even
the accented Latin scripts needed more room to be expressed. Other
segmentally linear, monophonemic writing systems (e.g. Cyrillic, Hangul, or
Greek) would need replace the graphic characters wholesale. The idea of
describing syllabary-based languages in seven or even eight bits is
laughable\footnote{An octet character set for ``rudimentary form'' Japanese,
containing only the \textit{katakana}, was introduced as JIS X 0201-1976.}.

With the high bit of an octet byte going largely unused as a parity bit, the
seven-bit character sets were rapidly expanded into a wide variety of eight-bit
character sets (sometimes mistakenly referred to as ``extended'' or ``high'' ASCII).

\textbf{FIXME FIXME}

This discordant cacophony gave rise to \textit{mojibake} (文字化け [{\fontspec{DejaVu Serif}mod͡ʑibake}]),
the garbled result of mismatched character encoding and decoding\footnote{Japanese, from 文字 (moji (character))
化ける (bakeru (take a different form)). Russians know it as \textrussian{кракозя́бры}
(krakozyabry [{\fontspec{DejaVu Serif}krɐkɐˈzʲæbrɪ̈}]) or sometimes
\textrussian{бНОПНЯ} (bnopnjá {\fontspec{DejaVu Serif}bnɐpˈnʲa}), while
Bulgarians speak of \textbulgarian{маймуница} (majmunica (monkey alphabet)).
Serbs cut to a characteristically Balkan chase with \textrussian{ђубре} (đubre
(trash)). I {\fontspec{DejaVu Serif}�} Unicode.}.

\subsection{Consilience: the Universal Character Set}
\label{sec:ucs}
\begin{figure}[!htb]
  \centering
  \includegraphics[width=1.1\linewidth]{media/unicode-growth.png}
  \caption{2020's Unicode 13.0 ships 143,859 character definitions.}
  \label{fig:unicodegrowth}
\end{figure}

\begin{table}[!htb]
  \begin{center}
    \begin{tabular}{ |c|p{.65\textwidth}| }
      \hline
      Principle & Statement \\
      \hline
      \hline
      Universality & The Unicode Standard provides a single, universal repertoire. \\
      \hline
      Efficiency & Unicode text is simple to parse and process. \\
      \hline
      Characters, not glyphs & The Unicode Standard encodes characters, not glyphs. \\
      \hline
      Semantics & Characters have well-defined semantics. \\
      \hline
      Plain text & Unicode characters represent plain text. \\
      \hline
      Logical order & The default for memory representation is logical order. \\
      \hline
      Unification & The Unicode Standard unifies duplicate characters within scripts across languages. \\
      \hline
      Dynamic composition & Accented forms can be dynamically composed. \\
      \hline
      Stability & Characters, once assigned, cannot be reassigned and key properties are immutable. \\
      \hline
      Convertibility & Accurate convertibility is guaranteed between the Unicode Standard and other widely accepted standards. \\
      \hline
    \end{tabular}
  \end{center}
  \caption[The ten Unicode design principles.]{The 10 Design Principles of Unicode (Unicode Core Specification §2.2\cite{unicode}).}
  \label{table:ucsdesign}
\end{table}
The Universal Character Set (ISO 10646\footnote{Note that this is 10,000 more than ISO 646.},
the character set underlying Unicode) was introduced to resolve these problems,
as a ``unique, universal, and uniform character encoding''\cite{unicodehistory}. The
Unicode Consortium traces its origin to Joe Becker's paper, ``Unicode 88''\cite{unicode88}.
Often in these early documents, UCS is described as a ``16-bit character set''.
This is perhaps partially responsible for the widespread misconception that UTF-16\cite{rfc2781}
can encode all UCS code points in a single 16-bit unit. 16 bits are sufficient
to encode any given UCS \textit{plane} of up to 65,536 code points, and indeed a great
many languages are contained within the first UCS plane, the Basic Multilingual
Plane (0x0--0xffff). There are a total of 17 planes available in
UCS\footnote{Once upon a time, these other sixteen planes were known as the
Astral Planes\cite{astralplanes}.}, however, and UTF-16 requires two code
units to encode points from these other 16 planes (0x10000--0x10ffff).

\begin{table}[!htb]
  \begin{center}
    \begin{tabular}{ |c|c|p{.6\textwidth}| }
      \hline
      Plane & ID & Purpose \\
      \hline
      \hline
      Basic Multilingual & 0 & Common-use characters for modern and historical scripts. \\
      \hline
      Supplementary Multilingual & 1 & Spillover from BMP. \\
      \hline
      Supplementary Ideographic & 2 & CJK spillover from BMP. \\
      \hline
      Supplementary special-purpose & 14 & Format control spillover. \\
      \hline
      Supplementary Private Use A & 15 & Local semantics. \\
      \hline
      Supplementary Private Use B & 16 & Local semantics. \\
      \hline
    \end{tabular}
  \end{center}
  \caption[The six named UCS planes.]{The six named UCS planes (Unicode Core Specification §2.8\cite{unicode}).}
  \label{table:ucsplanes}
\end{table}

\textbf{FIXME FIXME FIXME}

\subsection{Fixed-width fonts ain't so fixed}

Notcurses assumes that all glyphs occupy widths which are an integral multiple
of the smallest possible glyph's cell width (aka a ``fixed-width font'').
Unicode introduces characters which generally occupy two such cells, known as
wide characters (though in the end, width of a glyph is a property of the
font). It is not possible to print half of such a glyph, nor is it generally
possible to print a wide glyph on the last column of a terminal.

Notcurses does not consider it an error to place a wide character on the last
column of a line. It will obliterate any content which was in that cell, but
will not itself be rendered. The default content will not be reproduced in such
a cell, either. When any character is placed atop a wide character's left or
right half, the wide character is obliterated in its entirety. When a wide
character is placed, any character under its left or right side is annihilated,
including wide characters. It is thus possible for two wide characters to sit
at columns 0 and 2, and for both to be obliterated by a single wide character
placed at column 1.

Likewise, when rendering, a plane which would partially obstruct a wide glyph
prevents it from being rendered entirely. A pathological case would be that of
a terminal $n$ columns in width, containing $n-1$ planes, each 2 columns wide.
The planes are placed at offsets $[0\ldots n-2]$. Each plane is above the plane to
its left, and each plane contains a single wide character. Were this to be
rendered, only the rightmost glyph would be visible!

Finally, fonts and font engines which yield glyphs wider (or narrower) than
\texttt{wcwidth()} would lead Notcurses to believe can cause problems. It is
best to avoid EGCs known to be very wide, or to avoid fonts which generate very
wide glyphs. Some examples are shown in Figure~\ref{fig:wideglyphs}.

\begin{figure}[!htb]
\centering
\includegraphics[width=1\linewidth]{media/wide-unicode.png}
\caption[Some very wide Unicode glyphs]{Some very wide Unicode glyphs (font: Hack 10)}
\label{fig:wideglyphs}
\end{figure}

\subsection{Emoji}
\textbf{FIXME FIXME FIXME}

You might have seen what appeared to be emoji flags of the world. The Unicode
Consortium, in their wisdom, wanted nothing to do with such geopolitical
questions. Instead, the 26 ``Regional Indicator Symbols``---one for each
letter of the ISO basic Latin alphabet\cite{iso646}---can be used to encode
ISO 3166-1\cite{iso3166} two-letter country codes\cite{darkcorners}. Some fonts contain flag
glyphs, and some layout engines will map pairs of these symbols to flags. The
UCS \textit{does not} contain national ``flag emoji'' (it does have some other
flags, though---see Table~\ref{table:flags}\footnote{Using a green block,
it is possible to generate the flag of the Great Socialist People's Libyan Arab Jamahiriya through 2011.}).

\begin{table}[!htb]
  \centering
  \begin{tabular}{|l|l|l|}
  \hline
  Character & Version & Comments \\
  \hline
  \hline
  🎌 U+1F38C CROSSED FLAGS & Unicode 6.0 & why Japanese crossed flags? \\
  \hline
  🏁 U+1F3C1 CHEQUERED FLAG & Unicode 6.0 & ``chequered'' whatever \\
  \hline
  🏳 U+1F3F3 WAVING WHITE FLAG & Unicode 7.0 & surrender! \\
  \hline
  🏴  U+1F3F4 WAVING BLACK FLAG & Unicode 7.0 & the Nick Black flag amirite \\
  \hline
  🚩 U+1F6A9 TRIANGULAR FLAG ON POST & Unicode 6.0 & suspiciously golf-related \\
  \hline
  \end{tabular}
  \caption{Flags in Unicode 13 \xelatexemoji{1f3f4-200d-2620-fe0f}.}
  \label{table:flags}
\end{table}

There are also official and non-official EGCs that commonly render flags, including
the Jolly Roger (U+1F3F4+U200D+U2620+UFE0F, \xelatexemoji{1f3f4-200d-2620-fe0f}),
Gilbert Baker's rainbow flag (U1F3F3+U200D+U1F308+UFE0F, \xelatexemoji{1f3f3-200d-1f308+fe0f}) and even Monica Helms's
transgender flag (U1F3F3+U200D+U26A7+UFE0F, \xelatexemoji{1f3f3-200d-26a7-fe0f}).
If you don't like the latter, you can always throw U20E0 COMBINING ENCLOSING
CIRCLE BACKSLASH atop it:\xelatexemoji{1f3f3-200d-1f308-20e0-fe0f}. It's a big Unicode tent, and there are plenty
of EGCs for everybody.

The downside of using such complexly combined EGCs is of course that what's
intended to be a single EGC can be broken into multiple EGCs by the font
rendering system. Suddenly, instead of \xelatexemoji{1f3f4-200d-2620-fe0f}
you've got an inscrutable \texttt{🏴☠}. To add insult to injury, this will
almost certainly screw up geometry through the end of the line, since Notcurses
will have an incorrect concept of the cursor's horizontal position. This
assumes that the font in use has even the basic component glyphs---in the very
limited Linux console font, it's unlikely that anything good can come of using
composed emoji. Note furthermore that while it is sometimes possible to set the
background color of colored emoji, the foreground color can only rarely be
controlled. When used properly under aligned stars, however, emoji can make
your TUI pop like nothing else.

\subsection{Stupid Unicode tricks}
Perhaps the single most useful Unicode character is U+2580 UPPER HALF BLOCK (▀),
or alternatively its inverse U+2584 LOWER HALF BLOCK (▄).

\textbf{FIXME} cyclic groups, reversals, zalgo, \url{http://qaz.wtf/u/, half blocks}

\subsection{UTF-8}
\textbf{FIXME FIXME FIXME}
\cleardoublepage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{planes}
\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% output and styling
\input{output}
\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Lines, boxes, and fills}
\subsection{Linear interpolation (``lerping'') and lines}
\label{sec:lerps}
\begin{listing}[!htb]
\begin{minted}{C}
// Draw horizontal or vertical lines using the specified cell, starting at the
// current cursor position. The cursor will end at the cell following the last
// cell output (even, perhaps counter-intuitively, when drawing vertical
// lines), just as if ncplane_putc() was called at that spot. Return the
// number of cells drawn on success. On error, return the negative number of
// cells drawn.
int ncplane_hline_interp(struct ncplane* n, const cell* c, int len, uint64_t c1, uint64_t c2);

static inline int ncplane_hline(struct ncplane* n, const cell* c, int len){
  return ncplane_hline_interp(n, c, len, c->channels, c->channels);
}

int ncplane_vline_interp(struct ncplane* n, const cell* c, int len, uint64_t c1, uint64_t c2);

static inline int ncplane_vline(struct ncplane* n, const cell* c, int len){
  return ncplane_vline_interp(n, c, len, c->channels, c->channels);
}
\end{minted}
\caption{Functions for drawing lines.}
\label{list:lines}
\end{listing}

\subsection{Boxes}
\label{sec:boxes}
Rectangles are regularly required as borders and for grouping. Notcurses supports
flexible box drawing. Boxes have their upper-left corner at the current cursor
position, unless drawn with \texttt{ncplane\_perimeter()}, which draws along the
edges of the plane (and has its upper-left corner at the plane origin). Box-drawing
functions accept six \texttt{cell} objects, one for each corner, one for horizontal
lines, and one for vertical lines. It is possible to apply linear interpolation
between the corners, in which case the colors of the horizontal and vertical
line-drawing cells will be ignored. It is possible to draw none, all, or any set
of the four corners and none, all, or any set of the four sides. These configurable
behaviors are specified via the \texttt{ctlword} bitmask parameter.

\texttt{ctlword} is defined in the least significant byte, where bits 4--7 are a
gradient mask, and 0--3 are a border mask:

\begin{table}[!htb]
  \centering
  \begin{tabular}{|l|l|l|}
    \hline
    Constant & Bit & Propery \\
    \hline
    \hline
    \texttt{NCBOXMASK\_TOP} & 0x001 & Inhibit top \\
    \hline
    \texttt{NCBOXMASK\_RIGHT} & 0x002 & Inhibit right \\
    \hline
    \texttt{NCBOXMASK\_BOTTOM} & 0x004 & Inhibit bottom \\
    \hline
    \texttt{NCBOXMASK\_LEFT} & 0x008 & Inhibit left \\
    \hline
    \texttt{NCBOXGRAD\_TOP} & 0x010 & Left side linear interpolation \\
    \hline
    \texttt{NCBOXGRAD\_RIGHT} & 0x020 & Bottom side linear interpolation \\
    \hline
    \texttt{NCBOXGRAD\_BOTTOM} & 0x040 & Right side linear interpolation \\
    \hline
    \texttt{NCBOXGRAD\_LEFT} & 0x080 & Top side linear interpolation \\
    \hline
    x & 0x100 & Require 1 connecting edge to draw corner \\
    \hline
    x & 0x200 & Require 2 connecting edges to draw corner \\
    \hline
    x & 0x300 & Draw no corners \\
    \hline
  \end{tabular}
  \caption{\texttt{ctlword} parameter for box-drawing.}
  \label{table:boxes}
\end{table}

By default, vertexes are drawn whether their connecting edges are drawn or
not. The value of the bits corresponding to \texttt{NCBOXCORNER\_MASK} (0x300)
control this, and are interpreted as the number of connecting edges necessary to draw a
given corner. At 0 (the default), corners are always drawn. At 3, corners
are never drawn (as at most 2 edges can touch a box's corner).

\begin{listing}[!htb]
\begin{minted}{C}
int ncplane_box(struct ncplane* n, const cell* ul, const cell* ur, const cell* ll, const cell* lr,
                const cell* hline, const cell* vline, int ystop, int xstop, unsigned ctlword);

// Draw a box with its upper-left corner at the current cursor position, having dimensions 'ylen'x'xlen'.
// See ncplane_box() for more information. The minimum box size is 2x2, and it cannot be drawn off-screen.
static inline int
ncplane_box_sized(struct ncplane* n, const cell* ul, const cell* ur, const cell* ll,
                  const cell* lr, const cell* hline, const cell* vline, int ylen, int xlen, unsigned ctlword){
  int y, x;
  ncplane_cursor_yx(n, &y, &x);
  return ncplane_box(n, ul, ur, ll, lr, hline, vline, y + ylen - 1, x + xlen - 1, ctlword);
}

static inline int
ncplane_perimeter(struct ncplane* n, const cell* ul, const cell* ur, const cell* ll,
                  const cell* lr, const cell* hline, const cell* vline, unsigned ctlword){
  if(ncplane_cursor_move_yx(n, 0, 0)){
    return -1;
  }
  int dimy, dimx;
  ncplane_dim_yx(n, &dimy, &dimx);
  return ncplane_box_sized(n, ul, ur, ll, lr, hline, vline, dimy, dimx, ctlword);
}
\end{minted}
\caption{Functions for drawing rectilinear boxes.}
\label{list:boxes}
\end{listing}

It can be tedious to set up the six \texttt{cell} parameters to these functions. Since
boxes are typically drawn with one of a small number of sets of EGCs, helper functions
are provided for each set. I usually go with the pleasantly rounded ``Light Arc'' Box
Drawing codes (Listing~\ref{list:roundboxes}).

\begin{listing}[!htb]
\begin{minted}{C}
static inline int
cells_rounded_box(struct ncplane* n, uint32_t attr, uint64_t channels,
                  cell* ul, cell* ur, cell* ll, cell* lr, cell* hl, cell* vl){
  return cells_load_box(n, attr, channels, ul, ur, ll, lr, hl, vl, "╭╮╰╯─│");
}

static inline int
ncplane_rounded_box(struct ncplane* n, uint32_t attr, uint64_t channels,
                    int ystop, int xstop, unsigned ctlword){
  int ret = 0;
  cell ul = CELL_TRIVIAL_INITIALIZER, ur = CELL_TRIVIAL_INITIALIZER;
  cell ll = CELL_TRIVIAL_INITIALIZER, lr = CELL_TRIVIAL_INITIALIZER;
  cell hl = CELL_TRIVIAL_INITIALIZER, vl = CELL_TRIVIAL_INITIALIZER;
  if((ret = cells_rounded_box(n, attr, channels, &ul, &ur, &ll, &lr, &hl, &vl)) == 0){
    ret = ncplane_box(n, &ul, &ur, &ll, &lr, &hl, &vl, ystop, xstop, ctlword);
  }
  cell_release(n, &ul); cell_release(n, &ur);
  cell_release(n, &ll); cell_release(n, &lr);
  cell_release(n, &hl); cell_release(n, &vl);
  return ret;
}

static inline int
ncplane_rounded_box_sized(struct ncplane* n, uint32_t attr, uint64_t channels, int ylen, int xlen, unsigned ctlword){
  int y, x;
  ncplane_cursor_yx(n, &y, &x);
  return ncplane_rounded_box(n, attr, channels, y + ylen - 1, x + xlen - 1, ctlword);
}
\end{minted}
\caption{Helpers for rounded-corner boxes.}
\label{list:roundboxes}
\end{listing}

Or, if you prefer, there are the strong, sure Double Box Drawing characters (Listing~\ref{list:doubleboxes}).

\begin{listing}[!htb]
\begin{minted}{C}
static inline int
cells_double_box(struct ncplane* n, uint32_t attr, uint64_t channels,
                 cell* ul, cell* ur, cell* ll, cell* lr, cell* hl, cell* vl){
  return cells_load_box(n, attr, channels, ul, ur, ll, lr, hl, vl, "╔╗╚╝═║");
}

static inline int
ncplane_double_box(struct ncplane* n, uint32_t attr, uint64_t channels,
                   int ystop, int xstop, unsigned ctlword){
  int ret = 0;
  cell ul = CELL_TRIVIAL_INITIALIZER, ur = CELL_TRIVIAL_INITIALIZER;
  cell ll = CELL_TRIVIAL_INITIALIZER, lr = CELL_TRIVIAL_INITIALIZER;
  cell hl = CELL_TRIVIAL_INITIALIZER, vl = CELL_TRIVIAL_INITIALIZER;
  if((ret = cells_double_box(n, attr, channels, &ul, &ur, &ll, &lr, &hl, &vl)) == 0){
    ret = ncplane_box(n, &ul, &ur, &ll, &lr, &hl, &vl, ystop, xstop, ctlword);
  }
  cell_release(n, &ul); cell_release(n, &ur);
  cell_release(n, &ll); cell_release(n, &lr);
  cell_release(n, &hl); cell_release(n, &vl);
  return ret;
}

static inline int
ncplane_double_box_sized(struct ncplane* n, uint32_t attr, uint64_t channels, int ylen, int xlen, unsigned ctlword){
  int y, x;
  ncplane_cursor_yx(n, &y, &x);
  return ncplane_double_box(n, attr, channels, y + ylen - 1, x + xlen - 1, ctlword);
}
\end{minted}
\caption{Helpers for doubly-thicc boxes.}
\label{list:doubleboxes}
\end{listing}

\subsection{Gradients and polyfills}
\texttt{ncplane\_polyfill()} should be applied to a coordinate with no glyph (Listing~\ref{list:polyfill}).
That coordinate will be filled with the provided \texttt{cell}. The function
then effectively recurses on all cardinally connected coordinates, thus filling
a bounded region with the provided cell. This operation is akin to the ``flood
fill'' of pixel graphics.

\begin{listing}[!htb]
\begin{minted}{C}
// Starting at the specified coordinate, if it has no glyph, 'c' is copied into
// it. We do the same to all cardinally-connected glyphless cells, filling in
// everything behind a boundary. Returns the number of cells polyfilled. An
// invalid initial y, x is an error.
int ncplane_polyfill_yx(struct ncplane* n, int y, int x, const cell* c);
\end{minted}
\caption{Polyfill (``flood fill'').}
\label{list:polyfill}
\end{listing}

A single EGC and attribute can be written to a rectangular region in any of
a single color, a vertical, horizontal, or diagonal gradient, or a 4-cornered
``inverted radial'' gradient (see Listing~\ref{list:gradients}). The gradient
operation is independently applied to both the fore- and background of 4 64-bit
channel parameters. Palette-indexed color is not yet supported for gradients.

\begin{listing}[!htb]
\begin{minted}{C}
// Draw a gradient with its upper-left corner at the current cursor position,
// stopping at 'ystop'x'xstop'. The glyph composed of 'egc' and 'attrword' is
// used for all cells. The channels specified by 'ul', 'ur', 'll', and 'lr'
// are composed into foreground and background gradients. To do a vertical
// gradient, 'ul' ought equal 'ur' and 'll' ought equal 'lr'. To do a
// horizontal gradient, 'ul' ought equal 'll' and 'ur' ought equal 'ul'. To
// color everything the same, all four channels should be equivalent. The
// resulting alpha values are equal to incoming alpha values.
//
// Preconditions for gradient operations (error otherwise):
//
//  all: only RGB colors, unless all four channels match as default
//  all: all alpha values must be the same
//  1x1: all four colors must be the same
//  1xN: both top and both bottom colors must be the same (vertical gradient)
//  Nx1: both left and both right colors must be the same (horizontal gradient)
int ncplane_gradient(struct ncplane* n, const char* egc, uint32_t attrword,
                     uint64_t ul, uint64_t ur, uint64_t ll, uint64_t lr,
                     int ystop, int xstop);

// Do a high-resolution gradient using upper blocks and synced backgrounds.
// This doubles the number of vertical gradations, but restricts you to
// half blocks (appearing to be full blocks).
int ncplane_highgradient(struct ncplane* n, uint32_t ul, uint32_t ur,
                         uint32_t ll, uint32_t lr, int ystop, int xstop);

// Draw a gradient with its upper-left corner at the current cursor position,
// having dimensions 'ylen'x'xlen'. See ncplane_gradient for more information.
static inline int ncplane_gradient_sized(struct ncplane* n, const char* egc, uint32_t attrword,
                                         uint64_t ul, uint64_t ur, uint64_t ll, uint64_t lr,
                                         int ylen, int xlen){
  if(ylen < 1 || xlen < 1){
    return -1;
  }
  int y, x;
  ncplane_cursor_yx(n, &y, &x);
  return ncplane_gradient(n, egc, attrword, ul, ur, ll, lr, y + ylen - 1, x + xlen - 1);
}

static inline int ncplane_highgradient_sized(struct ncplane* n, uint64_t ul, uint64_t ur,
                                             uint64_t ll, uint64_t lr, int ylen, int xlen){
  if(ylen < 1 || xlen < 1){
    return -1;
  }
  int y, x;
  ncplane_cursor_yx(n, &y, &x);
  return ncplane_highgradient(n, ul, ur, ll, lr, y + ylen - 1, x + xlen - 1);
}
\end{minted}
\caption{Drawing gradients.}
\label{list:gradients}
\end{listing}

\subsection{Blitting}
\label{sec:blitting}
\begin{listing}[!htb]
\begin{minted}{C}
// Blit a flat array 'data' of BGRx 32-bit values to the ncplane 'nc', offset from the upper left by
// 'placey' and 'placex'. Each row ought occupy 'linesize' bytes (this might be greater than lenx * 4
// due to padding). A subregion of the input can be specified with 'begy'x'begx' and 'leny'x'lenx'.
int ncblit_bgrx(struct ncplane* nc, int placey, int placex, int linesize, const unsigned char* data,
                int begy, int begx, int leny, int lenx);

// Blit a flat array 'data' of RGBA 32-bit values to the ncplane 'nc', offset from the upper left by
// 'placey' and 'placex'. Each row ought occupy 'linesize' bytes (this might be greater than lenx * 4
// due to padding). A subregion of the input can be specified with 'begy'x'begx' and 'leny'x'lenx'.
int ncblit_rgba(struct ncplane* nc, int placey, int placex, int linesize, const unsigned char* data,
                int begy, int begx, int leny, int lenx);
\end{minted}
\caption{Blitting BGRx and RGBA.}
\label{list:blitting}
\end{listing}

Sometimes, you've got a chunk of RGBA or BGRx in memory, and just want to blast
it onto a plane as quickly as possible. Blitting functions (see Listing~\ref{list:blitting})
exist to transform such pixels into Unicode Block Elements. Every two input rows
become a single row, using half-blocks when necessary. Columns are mapped 1-to-1.
This functionality was used, for instance, to set up Notcurses as a rendering
backend for NEStopia and RetroArch, and these functions form the heart of the
multimedia functionality described in Chapter~\ref{sec:libav}. Note that these
functions do not offer any scaling capabilities.

\subsection{Staining}
\label{sec:staining}
Consult Chapter~\ref{sec:outputtext} for the ``stainable'' family of text output
functions, allowing EGCs to be replaced without affecting attributes or channels.
To modify attributes or channels in isolation but \textit{en masse}, Notcurses
provides \texttt{ncplane\_format()} and \texttt{ncplane\_stain()}.

\begin{listing}[!htb]
\begin{minted}{C}
// Set the given style throughout the specified region, keepying content and
// channels otherwise unchanged.
int ncplane_format(struct ncplane* n, int ystop, int xstop, uint32_t attrword);

// Set the given channels throughout the specified region, keepying content and
// attributes otherwise unchanged.
int ncplane_stain(struct ncplane* n, int ystop, int xstop, uint64_t ul, uint64_t ur, uint64_t ll, uint64_t lr);
\end{minted}
\caption{Changing attributes or channels in isolation.}
\label{list:stain}
\end{listing}

\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\include{input}
\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Multimedia (images and videos)}
\label{sec:libav}

Media decoding and scaling is handled by libAV from FFmpeg, resulting in a
\texttt{notcurses\_visual} object. This object generates frames, each one
corresponding to a renderable scene on the associated plane. If Notcurses
is built without FFMpeg support, these functions will all return error.

\begin{listing}[!htb]
\begin{minted}{C}
// Open a visual (image or video), associating it with the specified ncplane.
// Returns NULL on any error, writing the AVError to 'averr'.
struct ncvisual* ncplane_visual_open(struct ncplane* nc, const char* file, int* averr);

// Destroy an ncvisual. Rendered elements will not be disrupted, but the visual
// can be neither decoded nor rendered any further.
void ncvisual_destroy(struct ncvisual* ncv);

// Render the decoded frame to the associated ncplane. The frame will be scaled
// to the size of the ncplane per the ncscale_e style. A subregion of the
// frame can be specified using 'begx', 'begy', 'lenx', and 'leny'. To render
// the rectangle formed by begy x begx and the lower-right corner, zero can be
// supplied to 'leny' and 'lenx'. Zero for all four values will thus render the
// entire visual. Negative values for any of the four parameters are an error.
// It is an error to specify any region beyond the boundaries of the frame.
int ncvisual_render(const struct ncvisual* ncv, int begy, int begx, int leny, int lenx);

// Return the plane to which this ncvisual is bound.
struct ncplane* ncvisual_plane(struct ncvisual* ncv);

// If a subtitle ought be displayed at this time, return a heap-allocated copy
// of the UTF8 text.
char* ncvisual_subtitle(const struct ncvisual* ncv);
\end{minted}
\caption{Opening, decoding, and rendering multimedia.}
\label{list:multimedia}
\end{listing}

\subsection{Streaming video/animated GIFs.}
\begin{listing}[!htb]
\begin{minted}{C}
// Called for each frame rendered from 'ncv'. If anything but 0 is returned,
// the streaming operation ceases immediately, and that value is propagated out.
typedef int (*streamcb)(struct notcurses* nc, struct ncvisual* ncv, void*);

// Shut up and display my frames! Provide as an argument to ncvisual_stream().
// If you'd like subtitles to be decoded, provide an ncplane as the curry. If the
// curry is NULL, subtitles will not be displayed.
static inline int ncvisual_simple_streamer(struct notcurses* nc, struct ncvisual* ncv, void* curry){
  if(notcurses_render(nc)){
    return -1;
  }
  int ret = 0;
  if(curry){
    // need a cast for C++ callers
    struct ncplane* subncp = (struct ncplane*)curry;
    char* subtitle = ncvisual_subtitle(ncv);
    if(subtitle){
      if(ncplane_putstr_yx(subncp, 0, 0, subtitle) < 0){
        ret = -1;
      }
      free(subtitle);
    }
  }
  return ret;
}

// Stream the entirety of the media, according to its own timing. Blocking,
// obviously. streamer may be NULL; it is otherwise called for each frame, and
// its return value handled as outlined for stream cb. Pretty raw; beware.
// If streamer() returns non-zero, the stream is aborted, and that value is
// returned. By convention, return a positive number to indicate intentional
// abort from within streamer(). 'timescale' allows the frame duration time to
// be scaled. For a visual naturally running at 30FPS, a 'timescale' of 0.1
// will result in 300FPS, and a 'timescale' of 10 will result in 3FPS. It is an
// error to supply 'timescale' less than or equal to 0.
int ncvisual_stream(struct notcurses* nc, struct ncvisual* ncv, int* averr,
                    float timescale, streamcb streamer, void* curry);
\end{minted}
\caption{Media streaming and \texttt{ncvisual\_simple\_streamer()}.}
\label{list:streaming}
\end{listing}

\subsection{Scaling images and video}
\begin{listing}[!htb]
\begin{minted}{C}
// How to scale the visual in ncvisual_open_plane(). NCSCALE_NONE will open a
// plane tailored to the visual's exact needs, which is probably larger than the
// visible screen (but might be smaller). NCSCALE_SCALE scales a visual larger
// than the visible screen down, maintaining aspect ratio. NCSCALE_STRETCH
// stretches and scales the image in an attempt to fill the visible screen.
typedef enum {
  NCSCALE_NONE,
  NCSCALE_SCALE,
  NCSCALE_STRETCH,
} ncscale_e;

// Open a visual, extract a codec and parameters, and create a new plane
// suitable for its display at 'y','x'. If there is sufficient room to display
// the visual in its native size, or if NCSCALE_NONE is passed for 'style', the
// new plane will be exactly that large. Otherwise, the plane will be as large
// as possible (given the visible screen), either maintaining aspect ratio
// (NCSCALE_SCALE) or abandoning it (NCSCALE_STRETCH).
struct ncvisual* ncvisual_open_plane(struct notcurses* nc, const char* file, int* averr, int y, int x, ncscale_e style);
\end{minted}
\caption{Scaling media onto a new plane.}
\label{list:scaling}
\end{listing}

\subsection{Sprites}
\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{UI widgets}
\label{sec:uiwidgets}
\subsection{Selectors and multiselectors}

The selector widget is an ncplane with a body section and optional title riser.
The body section is populated with options and descriptions, and supports
infinite scrolling up and down. The widget is automatically sized according to
the largest input provided. The keyboard and mouse wheel can scroll through
selections, and clicking on the arrows also scrolls. Selection and cancellation
are implemented by the caller. The currently-selected option can be retrieved
at any time. Option/description pairs can be added or removed while the
widget is active, even if the removed pair is currently selected. Removing the
last pair does not destroy the widget, and it is possible to create the widget
with no pairs.

\begin{listing}[!htb]
\begin{minted}{C}
struct selector_item {
  char* option;
  char* desc;
};

typedef struct selector_options {
  char* title; // title may be NULL, inhibiting riser, saving two rows.
  char* secondary; // secondary may be NULL
  char* footer; // footer may be NULL
  struct selector_item* items; // initial items and descriptions
  unsigned itemcount; // number of initial items and descriptions
  // default item (selected at start), must be < itemcount unless 'itemcount'
  // is 0, in which case 'defidx' must also be 0
  unsigned defidx;
  // maximum number of options to display at once, 0 to use all available space
  unsigned maxdisplay;
  // exhaustive styling options
  uint64_t opchannels;   // option channels
  uint64_t descchannels; // description channels
  uint64_t titlechannels;// title channels
  uint64_t footchannels; // secondary and footer channels
  uint64_t boxchannels;  // border channels
  uint64_t bgchannels;   // background channels, used only in body
} selector_options;

struct ncselector* ncselector_create(struct ncplane* n, int y, int x, const selector_options* opts);
\end{minted}
\caption{Selector creation.}
\end{listing}

\begin{figure}
    \centering
    \includegraphics[width=.75\linewidth]{media/selector1.png}
    \caption{Selector with a long title.}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=.75\linewidth]{media/selector2.png}
    \caption{Short title intersecting with header.}
\end{figure}

\begin{figure}
  \centering \includegraphics[width=.75\linewidth]{media/selector3.png}
    \caption{Selector with a long header.}
\end{figure}

\begin{figure}
\centering \includegraphics[width=.75\linewidth]{media/selector4.png}
\caption{Selector with a long footer and no header.}
\end{figure}

\begin{figure}
  \centering \includegraphics[width=.75\linewidth]{media/selector5.png}
  \caption{Naked selector.}
\end{figure}

\begin{listing}[!htb]
\begin{minted}{C}
int ncselector_additem(struct ncselector* n, const struct selector_item* item);
int ncselector_delitem(struct ncselector* n, const char* item);

// Return a reference to the selected option, or NULL if there are no items.
const char* ncselector_selected(const struct ncselector* n);

// Return a reference to the ncselector's underlying ncplane.
struct ncplane* ncselector_plane(struct ncselector* n);

// Move up or down in the list. A reference to the newly-selected item is
// returned, or NULL if there are no items in the list.
const char* ncselector_previtem(struct ncselector* n);
const char* ncselector_nextitem(struct ncselector* n);

// Offer the input to the ncselector. If it's relevant, this function returns
// true, and the input ought not be processed further. If it's irrelevant to
// the selector, false is returned. Relevant inputs include:
//  * a mouse click on an item
//  * a mouse scrollwheel event
//  * a mouse click on the scrolling arrows
//  * a mouse click outside of an unrolled menu (the menu is rolled up)
//  * up, down, pgup, or pgdown on an unrolled menu (navigates among items)
bool ncselector_offer_input(struct ncselector* n, const struct ncinput* nc);

// Destroy the ncselector. If 'item' is not NULL, the last selected option will
// be strdup()ed and assigned to '*item' (and must be free()d by the caller).
void ncselector_destroy(struct ncselector* n, char** item);
\end{minted}
\caption{Selector control.}
\end{listing}

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{media/multiselector.png}
    \caption{Multiselector.}
\end{figure}

\subsection{Menus}
\label{sec:menus}

Horizontal menu bars are supported on the top and bottom rows of planes. If a
menu bar is longer than the bound plane, it will be only partially visible, but
any unrolled section will be visible. Menus may be either visible or invisible
by default. Set the `hiding` option to get an invisible menu. In the event of a
screen resize, menus will be automatically moved/resized.

\begin{listing}[!htb]
\begin{minted}{C}
typedef struct menu_options {
  bool bottom;              // on the bottom row, as opposed to top row
  bool hiding;              // hide the menu when not being used
  struct {
    char* name;             // utf-8 c string
    struct {
      char* desc;           // utf-8 menu item, NULL for horizontal separator
      ncinput shortcut;     // shortcut, all should be distinct
    }* items;
    int itemcount;
  }* sections;              // array of menu sections
  int sectioncount;         // must be positive
  uint64_t headerchannels;  // styling for header
  uint64_t sectionchannels; // styling for sections
} menu_options;

struct ncmenu;

// Create a menu with the specified options. Menus are currently bound to an
// overall notcurses object (as opposed to a particular plane), and are
// implemented as ncplanes kept atop other ncplanes.
struct ncmenu* ncmenu_create(struct notcurses* nc, const menu_options* opts);
\end{minted}
\caption{Menu creation.}
\end{listing}

\begin{figure}
    \centering
    \includegraphics[width=.75\linewidth]{media/menutop.png}
    \caption{Menu along the top of the standard plane.}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=.75\linewidth]{media/menubottom.png}
    \caption{Menu along the bottom of the standard plane.}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=.75\linewidth]{media/menuwarmech.png}
    \caption[WarMECH and a translucent menu.]{The \texttt{notcurses-demo} menu, unrolled \textit{in media res}. Luigi, pursued
      by WarMECH, is leaping through the ``Help'' menu. In the upper left is the HUD,
      and at the bottom the About text, both implemented as translucent planes.}
\end{figure}

\begin{listing}[!htb]
\begin{minted}{C}
// Unroll the specified menu section, making the menu visible if it was
// invisible, and rolling up any menu section that is already unrolled.
int ncmenu_unroll(struct ncmenu* n, int sectionidx);

// Roll up any unrolled menu section, and hide the menu if using hiding.
int ncmenu_rollup(struct ncmenu* n);

// Return the selected item description, or NULL if no section is unrolled. If
// 'ni' is not NULL, and the selected item has a shortcut, 'ni' will be filled
// in with that shortcut--this can allow faster matching.
const char* ncmenu_selected(const struct ncmenu* n, struct ncinput* ni);

// Return the ncplane backing this ncmenu.
struct ncplane* ncmenu_plane(struct ncmenu* n);

// Offer the input to the ncmenu. If it's relevant, this function returns true,
// and the input ought not be processed further. If it's irrelevant to the
// menu, false is returned. Relevant inputs include:
//  * mouse movement over a hidden menu
//  * a mouse click on a menu section (the section is unrolled)
//  * a mouse click outside of an unrolled menu (the menu is rolled up)
//  * left or right on an unrolled menu (navigates among sections)
//  * up or down on an unrolled menu (navigates among items)
//  * escape on an unrolled menu (the menu is rolled up)
bool ncmenu_offer_input(struct ncmenu* n, const struct ncinput* nc);

// Destroy a menu created with ncmenu_create().
int ncmenu_destroy(struct ncmenu* n);
\end{minted}
\caption{Menu control.}
\end{listing}

\subsection{Reels}
\subsection{Example: let's rip off \texttt{whiptail}}
The \texttt{colloquy} program shipped with Notcurses implements a command-line
API similar to that of the Newt program \texttt{whiptail}, which itself ripped
off the NCURSES program \texttt{dialog}. All of these programs allow simple
user interfaces to be thrown up on the command line. \texttt{colloquy} is
written in Rust\footnote{\url{https://lib.rs/crates/colloquy}}, using the
Notcurses crate\footnote{\url{https://lib.rs/crates/notcurses}}, itself a wrapper
of the libnotcurses-sys\footnote{\url{https://lib.rs/crates/libnotcurses-sys}}
\texttt{bindgen}-generated Rust wrappers.

\textbf{FIXME FIXME FIXME example of each}

\section{Complex examples}
\subsection{Example: let's rip off tetris}
\label{sec:casestudy}
\subsection{Example: walking through \texttt{notcurses-demo}}
\label{sec:ncdemo}
The \texttt{notcurses-demo} program is built as part of Notcurses, and ought
have been installed alongside the library (on Debian, you'll need the
\texttt{notcurses-bin} package, and even then the demo has been somewhat
reduced in order to comply with the DFSG\cite{dfsg}). It demonstrates a wide
range of Notcurses capabilities, and its source code is most instructive.

It is best to run the demo in a terminal having geometry of at least 80x45,
though anything 80x24 or larger will more or less work (some content will be
clipped). It is also desirable to have 24-bit color enabled, assuming your
terminal supports it. Determine the number of colors advertised by your
terminal type using~\texttt{infocmp} (see Figure~\ref{fig:terminfocmp}).
Some relevant terminfo capabilities are described in Table~\ref{table:terminfo}.

\begin{table}[h]
  \begin{center}
    \begin{tabular}{ |c|c|c| }
      \hline
      \texttt{colors} & Integer & Number of colors. \\
      \hline
      \texttt{ccc} & Boolean & The palette can be programmed. \\
      \hline
      \texttt{RGB} & Boolean & Direct RGB values can be speficied. \\
      \hline
    \end{tabular}
  \end{center}
  \caption{Relevant terminfo properties.}
  \label{table:terminfo}
\end{table}

Each demo makes use of a few different Notcurses capabilities. In addition,
a menu is present throughout. From this menu (or using keyboard shortcuts),
you can activate a HUD (H) and an informational help display (Ctrl+u). In
addition, you can restart the demo with Ctrl+R, or quit at any time (q). This
application serves admirably for benchmarking certain terminal behaviors, and
we'll do exactly that in Appendix~\ref{sec:termshade}. The performance
properties of various components are described at length therein.

\begin{figure}[h]
  \centering
  \includegraphics[width=.75\linewidth]{media/terminfocmp.png}
  \caption{Inspecting the terminfo database.}
  \label{fig:terminfocmp}
\end{figure}

Screenshots were taken using \texttt{scrot} 1.2 and a 80x45
\texttt{xfce4-terminal} 0.8.9.1 from Xfce 4.14+Compiz 0.8.16.1 atop Xorg
1.20.7 on NVIDIA 440.59. All of these are the unmodified Debian Unstable
x86\_64 binaries. My kernel is a custom 5.5.6 build. The terminal type is
\texttt{xterm-256color}, and \texttt{COLORTERM} is defined to be
\texttt{24bit}. The terminal font was Hack 10, and the background is a 0.7
transparency.

\cleardoublepage

\begin{figure}
  \centering
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-intro.png}
    \caption[``Intro''.]{``Intro''. Lerps on the perimeters. Inverse radial
            gradient plus vertical gradient. Full-screen fade.
            Cyclic glyphs. Italics.}
  \end{minipage}\hfill
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-xray.png}
    \caption[``X-Ray''. Very large planes.]{``X-Ray''. Streaming video.
       Very large planes (the scrolling plane at the bottom is much larger than the visible screen).}
  \end{minipage}
\end{figure}

\begin{figure}
  \centering
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demoeagle2.png}
    \caption{``Eagle'', first phase.\\
      Parallax scrolling on large image.}
  \end{minipage}\hfill
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demoeagle1.png}
    \caption{``Eagle'', second phase.\\
      Sprites. Zoomed image.}
  \end{minipage}
\end{figure}

\begin{figure}
  \centering
  \begin{minipage}{0.30\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-trans1.png}
    \caption[``Trans'', early phase.]{``Trans''. Transparent top plane. Window through to the desktop.}
  \end{minipage}\hfill
  \begin{minipage}{0.30\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-trans2.png}
    \caption[``Trans'', middle phase.]{``Trans''. Opaque foreground, transparent background, no glyph.}
  \end{minipage}\hfill
  \begin{minipage}{0.30\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-trans3.png}
    \caption[``Trans'', late phase.]{``Trans''. Transparent foreground and background with opaque glyph.}
  \end{minipage}\hfill
\end{figure}

\begin{figure}
  \centering
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-highcon.png}
    \caption{``Highcon''. High-contrast text.}
  \end{minipage}\hfill
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-grid.png}
    \caption{``Grid''. Max RGB density.}
  \end{minipage}\hfill
\end{figure}

\begin{figure}
  \centering
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-box.png}
    \caption{``Box''. Lerped perimeters. Precise Unicode. Color sweeps.}
  \end{minipage}\hfill
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-sliders.png}
    \caption{``Sliders''. Partial fades. Animation. Gradients.}
  \end{minipage}\hfill
\end{figure}

\begin{figure}
  \centering
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-reels.png}
    \caption{``Reels''. The \texttt{ncreel} widget.}
  \end{minipage}\hfill
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-whiteout.png}
    \caption{``Whiteout''. Translucency.}
  \end{minipage}\hfill
\end{figure}

\begin{figure}
  \centering \includegraphics[width=.75\linewidth]{media/demo-chunli1.png}
  \caption{``Chunli''. Sprite animation.}
\end{figure}

\begin{figure}
  \centering \includegraphics[width=.75\linewidth]{media/demo-chunli2.png}
  \caption{``Chunli''. Sprite animation.}
\end{figure}

\begin{figure}
  \centering
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-uniblock1.png}
    \caption{``Uniblock''. Hangul syllables.}
  \end{minipage}\hfill
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-uniblock2.png}
    \caption{``Uniblock''. Emoji.}
  \end{minipage}\hfill
\end{figure}

\begin{figure}
  \centering
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-img1.png}
    \caption{``View''. Scaling an image.}
  \end{minipage}\hfill
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-img2.png}
    \caption{``View''. Transparent images.}
  \end{minipage}\hfill
\end{figure}

\begin{figure}
  \centering
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-view1.png}
    \caption{``View''. Streaming video with high-contrast text.}
  \end{minipage}\hfill
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-view2.png}
    \caption{``View''. Notice the high-contrast kicking in.}
  \end{minipage}\hfill
\end{figure}

\begin{figure}
  \centering \includegraphics[width=1\linewidth]{media/demojungle.png}
  \caption[``Jungle''. Palette-indexed image.]{``Jungle''. Palette-indexed image. Very low-bandwidth animation via palette cycling.\\
    ``Ruins in Rain'' © Mark Ferrari/Living Worlds. Texelized with permission.}
\end{figure}


\begin{figure}
  \centering
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-fallin1.png}
    \caption[``Fallin\''', early phase.]{``Fallin\'''. Color change, introspection, many planes.}
  \end{minipage}\hfill
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-fallin2.png}
    \caption[``Fallin\''', late phase.]{``Fallin\'''. The underlying image is revealed.}
  \end{minipage}\hfill
\end{figure}

\begin{figure}
  \centering
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-luigi.png}
    \caption{``Luigi''. Multiple sprites.}
  \end{minipage}\hfill
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-outro.png}
    \caption{``Outro''. Fades atop video.}
  \end{minipage}\hfill
\end{figure}

\clearpage
\cleardoublepage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{appendices}

\input{termhistory.tex}
\pagebreak
\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{benchmarks.tex}
\pagebreak
\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The Linux console}
The Linux console\footnote{The FreeBSD console is its own bag of wonders.} is
substantially different from the X and Wayland terminal emulators to which one
might be more accustomed\footnote{Muddying the issue is the fact that video
backends are sometimes described as consoles. The ``Linux console'' is a terminal
emulator running atop some video backend---on the x86, typically either VGA
Text Mode, or some trivial renderer atop a graphics-mode framebuffer
(e.\ g.\ EFIfb or vesafb.)}. Modern terminal emulators are generally more capable
than the Linux console in several ways:

\begin{denseitemize}
\item{While the Linux console accepts RGB specifiers, it downsamples them to
    far fewer colors.}
\item{Console font capabilities are extremely limited.}
\end{denseitemize}

Like any interface to a termios\cite{termios} implementation, the \texttt{IUTF8}
flag should be set (consult \texttt{stty}). This can be accomplished with the
\texttt{IUTF8} termios flag (or \texttt{stty iutf8} on the command line). This
is necessary for the terminal to interpret your output as multibyte UTF-8. The
keyboard driver ought be placed into UTF-8 mode using the \texttt{KDSKBMODE}
ioctl; the \texttt{kbd-mode} tool does this when invoked with \texttt{-u}.
This is necessary for character erase to function properly in cooked mode. Some
keyboards generate scancodes beyond the essential 128 characters, and these
should be mapped to their UTF-8 equivalents. This can be accomplished with
\texttt{dumpkeys | loadkeys --unicode}\footnote{If you've ever seen the script
\texttt{unicode\_start}, this is exactly what it does.}. This functionality has
been supported since Linux 2.6.4, released 2004-03-11, and is almost certainly
already being done in your environment.

Ensure, as always, that \texttt{LANG} is properly set, that your program
initializes the locale with \texttt{setlocale(3)}, and that \texttt{TERM} is
properly set (in this case, to one of the ``linux*'' variants).

\textbf{FIXME FIXME FIXME talk about console font}

Consult the \textit{The Linux Programmer's Manual} for more information,
particularly
\texttt{ioctl\_console(2)}\cite{ioctlconsole},
\texttt{ioctl\_tty(2)}\cite{ioctltty},
\texttt{termios(3)}\cite{termios},
\texttt{console\_codes(4)}\cite{consolecodes},
and
\texttt{charsets(7)}\cite{charsets7}.

\cleardoublepage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Unicode 13}
The Unicode Consortium has scheduled Unicode 13.0 for a March 2020 release.
Chapters 3 and most of Chapter 4 of the Core Specification are normative. The
remainder is informative. The Unicode Standard consists of the Core
Specification\cite{unicode13}, the \href{https://www.unicode.org/charts/}{code charts},
the \href{https://unicode.org/versions/Unicode13.0.0/#Unicode_Standard_Annexes_nb}{Unicode Standard Annexes},
and the \href{http://www.unicode.org/Public/13.0.0/}{Unicode Character Database (UCD)}.

A Unicode Standard Annex (UAX) forms an integral part of the Unicode Standard,
but is published online as a separate document. The Unicode Standard may
require conformance to normative content in a Unicode Standard Annex, if so
specified in the Conformance chapter of that version of the Unicode Standard.
The version number of a UAX document corresponds to the version of the Unicode
Standard of which it forms a part.

\begin{table}[h]
\begin{center}
  \begin{tabular}{ |c|c| }
    \hline
    UAX \#9 & Unicode Bidirectional Algorithm \\
    \hline
    UTS \#10 & Unicode Collation Algorithm \\
    \hline
    UAX \#11 & East Asian Width \\
    \hline
    UAX \#14 & Unicode Line Breaking Algorithm \\
    \hline
    UAX \#15 & Unicode Normalization Forms \\
    \hline
    UAX \#24 & Unicode Script Property \\
    \hline
    UAX \#29 & Unicode Text Segmentation \\
    \hline
    UAX \#31 & Unicode Identifier and Pattern Syntax \\
    \hline
    UAX \#34 & Unicode Named Character Sequences \\
    \hline
    UAX \#38 & Unicode Han Database (Unihan) \\
    \hline
    UTS \#39 & Unicode Security Mechanisms \\
    \hline
    UAX \#41 & Common References for Unicode Standard Annexes \\
    \hline
    UAX \#42 & Unicode Character Database in XML \\
    \hline
    UAX \#44 & Unicode Character Database \\
    \hline
    UAX \#45 & U-Source Ideographs \\
    \hline
    UTS \#46 & Unicode IDNA Compatibility Processing \\
    \hline
    UAX \#50 & Unicode Vertical Text Layout \\
    \hline
    UTS \#51 & Unicode Emoji \\
    \hline
  \end{tabular}
\caption{Unicode 13.0.0 Standard Annexes and Synchronized Technical Standards.}
\end{center}
\end{table}

\cleardoublepage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\section{Notcurses header files}
%\subsection{The \texttt{notcurses.h} header}
%\bgroup
%\inputminted[linenos,breaklines=true]{C}{code/notcurses.h}
%\egroup
%
%\subsection{The \texttt{nckeys.h} header}
%\bgroup
%\inputminted[linenos,breaklines=true]{C}{code/nckeys.h}
%\egroup

\end{appendices}
\cleardoublepage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\glsaddallunused
\printglossary[title={Glossary of terms}]
\cleardoublepage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\addcontentsline{toc}{section}{References}
\printbibliography
\cleardoublepage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace*{2in}
\addcontentsline{toc}{section}{Acknowledgments}
\begin{center}\textbf{Acknowledgments}\end{center}

This work would not have been possible without the early customers of
Dirty South Supercomputing; thank you Jeff Arnold at ShareCare,
Todd Wilson at Vakaros, Charles Brian Quinn at Greenzie, Carl Ledbetter
at SimpleRose, Keshav Attrey at PureStorage, Jaron Nix at Pathware,
Manuel Garcia at Cyxtera, and the folks who can't be mentioned. Keep
churning through DGEMMs and blowing shit up, everybody. Yacin Nadji,
Scott Hughes, Paige Bailey, Brendan Dolan-Gavitt and Joe Lafiosca were
particularly supportive of the Notcurses endeavor. Mark Ferrari let me use
his mindblowing palette-cycling pixel art, and was awfully sweet to a weird
dude emailing him from out of nowhere. GitHub has remained
shockingly useful and unoffensive for a Microsoft product. Robert Edmonds
helped me get Notcurses into Debian's NEW queue, and coached me in the ways
of the DFSG. Marek Habersack wrote the \CC wrapper, and has kept it up to date despite my
total lack of communication or warning before lunging in entirely new
API directions. Astrid Bin did the awesome DSSCAW logo\footnote{Minus the boss purple gradient, which I applied against her passionate wishes. I stand by my call.}, and I couldn't
pay her in the end due to bullshit laws---like, I even drunkenly called her up
and was like ``FUCK DA POLICE i'll drop a brown paper sack of \$10 bills
on your porch and steal you a social security number, arrrrrrrr'' and yet
she refused---thanks, Astrid! Thomas E. Dickey,
author/maintainer of many venerable trees including NCURSES, is a saint and an
angel, a UNESCO treasure, and the very model of conservative, thoughtful
software stewardship. He graciously answered my mails with lengthy and rigorous
information. The free software community owes him a great debt.

Shouts out to Midtown Yuppie Scum (ATL) and Stinkeye of the Tiger (NYC) Trivia
Clubs. Shouts out to Paul Johnson and Paul Judge. Shouts out to Outkast, Goodie
Mob, and RTJ. Shouts out to every freedom-loving person around the world
fighting the unceasing struggle against International Communism. God save the
Constitution and God save the Republic.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\cleardoublepage
%\vfill
%\begin{center}
%\includegraphics[width=.4\linewidth]{../common/dsscaw-purp-scaled.png}
%\includegraphics[width=.5\linewidth]{../common/south.png}
%\end{center}
%\vfill
%\includepdf{media/backcover.pdf}
\end{document}
