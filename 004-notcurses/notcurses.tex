% arara: xelatex: {shell: true}
% arara: biber
% arara: makeglossaries
% arara: xelatex: {shell: true}
% arara: xelatex: {shell: true}
\documentclass[letterpaper,10pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{newfloat}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage[font=small,labelfont=bf]{caption}
\usepackage{fancyhdr}
\usepackage{parskip}
\usepackage[section]{placeins}
\usepackage{epigraph}
\usepackage{sourcecodepro}
\usepackage{fontspec}
\usepackage[toc,nonumberlist,xindy]{glossaries}
\usepackage{relsize}
\setmonofont[Scale=0.7]{Source Code Pro}
\defaultfontfeatures{Ligatures=TeX}
\usepackage{xcolor}
\usepackage[titletoc,title]{appendix}
\usepackage{minted}
\usepackage{xeCJK}
\usepackage{tipa}
\usepackage{csquotes}
\usepackage{polyglossia}
\usepackage{arabxetex}
\setmainlanguage{english}
\setotherlanguages{hebrew,french,bulgarian,russian}
\newfontfamily\cyrillicfont[Script=Cyrillic]{Noto Sans}
\newfontfamily\hebrewfont[Scale=0.8,Script=Hebrew]{Frank Ruehl CLM}
\definecolor{dsscawpurp}{HTML}{b079b0}
\definecolor{dsscawpurpcap}{HTML}{6c286c}
\usepackage[font={color=dsscawpurpcap},labelfont={sc}]{caption}
\usepackage[backend=biber,
date=iso,
seconds=true,
style=numeric,
bibencoding=utf8,
]{biblatex}

\tracinglostchars=2

\addbibresource{\jobname.bib}
\usemintedstyle{friendly}
\newenvironment{denseitemize}{
  \begin{itemize}
      \setlength{\itemsep}{0pt}
}{
  \end{itemize}
}
% An attractive 'C++'
\newcommand\CC{C\nolinebreak\hspace{-.05em}\raisebox{.4ex}{\relsize{-3}{\textbf{+}}}\nolinebreak\hspace{-.10em}\raisebox{.4ex}{\relsize{-3}{\textbf{+}}}\hspace{.2em}}

\pagestyle{fancy}
\rhead{
  \includegraphics[height=\fontcharht\font`\D,keepaspectratio=true]{../dsscaw-hdr.pdf}
  \textcolor{dsscawpurp}{DSSCAW Technical Report \#004}
}

\title{Hacking the Planet! with Notcurses:\\
A Guide to TUIs and Character Graphics\thanks{
 \href{https://www.dsscaw.com/}{Dirty South Supercomputing of Atlanta, GA. Free documentation under the Apache 2.0 License.}
}\\
}
\author{Nick Black, Consulting Scientist\\
\texttt{nickblack@linux.com}
}

\makeglossaries
\setglossarypreamble{When possible, I have followed the definitions of
  RFC 2978\cite{rfc2978} and the Glossary of Unicode Terms\cite{unicodeglossary}.}
\loadglsentries{glossary}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\date{Feb 14, 2020}
\maketitle
%\thispagestyle{fancy}
\date{}
\vspace{1in}
\begin{center}
\includegraphics[width=.75\linewidth]{htp-with-notcurses.png}
\end{center}
\thispagestyle{empty}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\clearpage
\pagenumbering{roman}

\vspace*{1in}
\begin{center}
  \textit{For T.\ S.\ Eliot, il miglior fabbro.} \\
  \vspace{.25in}
  \textit{For Jeanette Martin, for exhortations to go H.A.M. \\
  \vspace{.25in}
  For Jim Greenlee, for speaking rigor to my programming.\\
  \vspace{.25in}
    For Prof.\ Hyesoon Kim, for introducing me to the glorious world
    inside the die.\\
  \vspace{.25in}
    For Prof.\ Richard Vuduc, for demonstrating serenity in brilliance, and kindness in dominance.\\}

  \vspace{1in}\ldots but mostly for Emily.
\end{center}
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents

\cleardoublepage
\phantomsection
\addcontentsline{toc}{section}{\listfigurename}
\listoffigures
\listoflistings
\listoftables
\vfill
\begin{center}
\includegraphics[width=1\linewidth]{media/widechars.png}
\end{center}
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

\vspace*{1.25in}
\begin{figure}[!htbp]
\centering
\includegraphics[width=1\linewidth]{media/ibm3270.jpg}
\caption[A programmer at her IBM 3270]{A programmer at her IBM 3270 2A. \textit{Source: Jonathan Schilling}.}
\end{figure}
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\vspace*{1in}
\section{Foreward}
Copyright © 2020 Nick Black.

This edition corresponds to version 1.2.2 of the Notcurses
library, released 2020-02-24.

Notcurses can be downloaded from
\url{https://github.com/dankamongmen/notcurses}.

This document can be downloaded
from~\url{https://nick-black.com/htp-notcurses.pdf}.

Licensed under the Apache License, Version 2.0 (the ``License''); you may not
use this document except in compliance with the License. You may obtain a copy
of the License at \url{http://www.apache.org/licenses/LICENSE-2.0}.

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an ``AS IS'' BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

This work in its entirety is Free Documentation, written for love and released
to instruct. You should not have been charged for this document. If you'd like
to show thanks for my efforts, I encourage a donation to
the~\href{https://www.thefire.org/}{Foundation for Individual Rights in Education}.

Tetris © The Tetris Company, LLC.
\textit{Hackers (1995)} © United Artists Pictures.
\textit{House of Leaves (2000)} © Penguin Random House.
``Ruins with Rain'' © Mark Ferrari/Living Worlds.
``Final Fantasy'' © Square Enix Co Ltd.
``Super Mario Bros.'' © Nintendo of America.
``Ninja Gaiden'' © Koei Tecmo America.
``Street Fighter II'' and ``Mega Man 2'' © Capcom of America.
Please don't sue me.

\subsection{¡Peligro!}

The code written for this book attempts to minimize use of vertical space
without eliding error checking (or crossing into the realms of the grotesque).
Error handling is a fundamental slog of C programming, one that
inevitably complicates reliable applications.

\textbf{These listings cannot be considered examples of good general style\ldots but they get the job done.}

\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagenumbering{arabic}

\epigraph{Our fine arts were developed, their types and uses were established, in times
very different from the present, by men whose power of action upon things was
insignificant in comparison with ours. But the amazing growth of our
techniques, the adaptability and precision they have attained, the ideas and
habits they are creating, make it a certainty that profound changes are
impending in the ancient craft of the Beautiful.}{Paul Valéry}
\section{Introduction}

I implemented Notcurses in the winter of 2019 after having a few patches
rejected from NCURSES. The first commit was pushed 2019-11-16. It proved to
be seductive as hell, and it was only with difficulty that I tore myself away
following three months of hard work. I started writing this manuscript
2020-02-12, following the 1.1.8 release. By that time, Notcurses subsumed large
chunks of NCURSES, adding a great deal more. The project had three major goals:

\begin{denseitemize}
\item to provide NCURSES-like functionality with 24-bit color, safety in the
    presence of multithreading, and full Unicode support,
\item to reduce the amount of boilerplate code necessary for the UIs of my
    TUI applications, including \textit{growlight} and \textit{omphalos}, and
\item to portably facilitate the most vivid character graphics possible.
\end{denseitemize}

Many people asked how such a thing was useful. My usual response was that
numerous devices don't present a bitmap interface, that X11 GUIs run remotely
over SSH are effectively unusable, that plenty of machines don't have a GUI
environment installed, that there are obvious applications for large outdoor
displays, and that Sixel isn't well-supported across different
terminal emulators. It seems impossible in an age of gigatransistor graphics
cards, but the text environment still presents perceivably less latency
than most GUI toolkits. That I was able to remove thousands of lines
of NCURSES code from my applications was a nice side benefit.

In truth, the main reasons were that it was fun, and I wanted to see how far
I could push it.

As I write this, Notcurses is present in Arch's AUR, and is awaiting promotion
from the Debian Incoming queue. Written as a C core, it enjoys \CC, Python, and
Rust wrappers. I have submitted it as a backend to NEStopia and RetroArch, and
intend to integrate it into Mesa as an OpenGL backend. So long as one can live
with the limited resolution available when a screen is divided into rectangular
cells, it can handle any graphics thrown at it. I hope to see it displace
NCURSES as the go-to character graphics library for new applications (there is
little value in porting existing applications to Notcurses, since an unchanged
application wouldn't take advantage of its advanced features).

While the X/Open Curses specification is unlikely to ever go away (nor should
it, as a lowest-common-denominator interface to devices Notcurses is unlikely
to ever support), I believe Notcurses to present a superior API and
implementation for modern TUI applications.

The console ain't dead! Hack on, hax0rs.

\vfill

\begin{flushright}
  \textit{---February 2020, Atlanta}
\end{flushright}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\vfill
\begin{center}
%\includegraphics[width=.4\linewidth]{../common/dsscaw-purp-scaled.png}
%\includegraphics[width=.5\linewidth]{../common/south.png}
\includegraphics[width=.75\linewidth]{media/chunli-box-front.png}
\end{center}
\vfill
\section{Right, what's all this, then?}
Character graphics, aka text mode, aka the display side of a terminal, is
visualization that works with fonts rather than a pixel framebuffer\footnote{``Contones'', as raster graphics are known to printers.}
or a vector canvas\footnote{Nothing keeps you from implementing character graphics
with pixels or vectors, of course.}. There is furthermore an expectation that
this font is a fixed-width one---that all rendered glyphs are integer multiples
of some narrowest non-trivial glyph.

Given the same display hardware,

\begin{denseitemize}
\item{Character graphics are usually strictly less powerful than pure raster graphics, and}
\item{their lower effective resolution typically implies lower bandwidth requirements.}
\end{denseitemize}

A TUI (text user interface) is a holistic model, view, and controller implemented
using character graphics. TUIs, like WIMP\footnote{Windows, icons, menus, pointers, a paradigm so pervasive that
the industry collectively treasures a Wiemarian memory of Xerox PARC's noble
engineers stabbed in the back by management (not unlike the Oatmeal-fostered\cite{fuckoatmeal}
myopia regarding Edison and Tesla. I'll take Thomas Alva over Matthew Inman any
day). It too often goes unmentioned that the Alto and Star were as unusable as they were visionary\cite{lightningdealers}.
This is of course still superior to Java, which isn't even visionary.} GUIs,
freely move the cursor around their rectilinear display, as opposed to
line-oriented CLIs and their ineluctable marches through the scrolling region.

Given the same interactive task\footnote{These relations are not
fundamental, but emerge from the grim meathook realities of GUI toolkits.}

\begin{denseitemize}
\item{A TUI implementation is almost certainly a smaller memory and disk footprint than a GUI,}
\item{a good TUI implementation might introduce less latency, and}
\item{a properly-done TUI implementation can often be significantly more portable.}
\end{denseitemize}

Of course, it can also be a big pile of character graphics shit.

For over two decades, NCURSES (a free software implementation of the X/Open Curses\cite{cursesosi}
specification, plus extensions\cite{ncursesfaq}) has been a ubiquitous go-to for implementing
TUIs. Maintainter (and author, in large part) Thomas E.\ Dickey,
exemplifies conservative and fastidious stewardship. Perfectly lovely TUIs can
be built using NCURSES (as seen in Figure~\ref{fig:ncurses-tuis}), but it \textit{does}
have its origins in the 8-bit era, and is showing its age.

\begin{figure}[!hbtp]
  \centering
    \includegraphics[width=.4\linewidth]{media/tui-ncmpcpp.png}
    \hfill
    \includegraphics[width=.4\linewidth]{media/tui-omphalos.png}
    \caption[NCURSES TUIs: Ncmpcpp and Omphalos.]
    {\texttt{ncmpcpp}, a \CC application
      that has driven my Music Player Daemon since 2008 or so.
      \texttt{omphalos}, a C application
      written using NCURSES in its extended mode.}
  \label{fig:ncurses-tuis}
\end{figure}

\begin{figure}[!htbp] \centering
    \includegraphics[width=.4\linewidth]{media/tui-mapscii.png}
    \hfill
    \includegraphics[width=.4\linewidth]{media/tui-growlight.png}
    \caption[Non-NCURSES TUIs: Mapscii and Growlight.]{\texttt{mapscii}, a
    node.js application, blew my mind when I first saw it. The high resolution
    is achieved by using Braille characters, trading away some color control.
    \texttt{growlight} began life as an NCURSES C program, but was ported to
    Notcurses in 2019.}
  \label{fig:notncurses-tuis}
\end{figure}

Implementing a TUI will usually require, at a minimum:
\begin{denseitemize}
\item{Receiving input from user devices, including keyboards and mice,}
\item{some manner of user configuration widgets (menus, etc.),}
\item{watching for some other event(s) from the system, and},
\item{juggling these various components without wastefully polling, nor
       introducing undue latency, and enforcing safe synchronized access to
       the graphics interface.}
\end{denseitemize}

Perhaps most terrifyingly, it will require user interface design. Notcurses
attempts to assist with this by providing numerous ready-made widgets.

This text has two goals:
\begin{denseitemize}
\item{To provide a firm footing for design and implementation of character
    graphics and TUIs, elucidating the dimensions of design, along with difficulties
    to avoid, and}
\item{to serve as ``narrative reference'' for my Notcurses library, and as
    a starting place for newcomers.}
\end{denseitemize}

\begin{figure}[!htbp]
\centering \includegraphics[width=.5\linewidth]{media/emacs-xerox.jpg}
  \caption{Put not your trust in hackers making a fetish of Xerox PARC.}
  \label{fig:xeroxemacs}
\end{figure}

Cell graphics are primarily the realm of \textit{terminals}, which for the
purposes of this book encompass any means by which input devices act to provide
input to a some process generating glyph-based output to a display. This
includes hardware terminals (inputs integrated with displays, connected to a
computer as a unit), operating system consoles (text-mode interfaces operating
with the graphics engine directly connected to the terminal driver), terminal
multiplexers (tools like \texttt{screen}, \texttt{tmux}, and \texttt{mosh},
providing a memory-persistent virtual terminal with which other terminals can
interact), and terminal emulators (applications which present a virtual
terminal atop the shared input and raster output methods of a graphical user
environment). There's some vagueness and variety involved with these terms.

At its heart, a terminal is a line discipline plus two buffers: an input buffer
to collect user-generated events (possibly from multiple devices), and an
output buffer to be processed and displayed. The buffers can be modeled as byte
streams, mutating the output at the time of their display (in contrast to e.g.\
a framebuffer, where the entirety of the screen is present at any given time).
The earliest terminals were electromechanical teletypes, reproducing their
input as line-based print on paper. These gave rise to ``dumb terminals''
(cathode-ray displays with a scrolling rectilinear output area). ``Smart
terminals'' followed, with the ability to move freely within their display
area, and also to extract and act upon ``control codes'' embedded in the output
stream. The text modes of the first video cards were designed around the
capabilities of these smart terminals. This brings us to the present, wherein
high-powered LED displays have their pixels summoned up and ordered into
formations suitable for the reconstruction of 1970s technology (a history of
terminals is presented in Appendix~\ref{sec:terminals}).

The machine on which I'm typing this contains a
TU104 GPU consisting of over thirteen billion 12nm-process transistors,
rendering its output to a 3440x1440 (almost five megapixel) display. Deep
within its silicon heart remains a VGA 80x25 text mode engine\cite{vga}, inherited
largely unchanged from the EGA, the CGA, the IBM Monochrome Display Adapter\footnote{The
history of video display standards since 1981's MDA is a story of imprecision,
dashed hopes, and idle dreams. Good luck finding authoritative references
for anything beyond \texttt{int 10h} real mode operation prior to version 1.0
of the SuperVGA VESA BIOS Extension\cite{videostandards}, released 1989-10-01\cite{vesa}.},
and before that smart terminals\footnote{As early as 1971, the block-oriented
IBM 3277 Model 2 ``green screen'' shipped with 80x24.}.


I generally use this modern marvel to drive terminal emulators of 80 columns.

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Using direct mode with standard I\/O}

Many tools don't intend to be full-screen TUI applications, but instead
implement that purest of UNIX interfaces: newline-delimited text, oblivious
to screen geometry, capable of being fed as input to other, similar programs.
For such tools, the full Notcurses capabilities are neither necessary nor
desirable. These programs are typically non-interactive: humans might peruse
their outputs and prepare their inputs, but they effectively run as a batch
task.

 Such tools might still want to colorize and otherwise style their output, at
least when being output to a terminal. This can be accomplished using the
\texttt{ncdirect} subset of Notcurses, and is known as \textit{direct mode}. Direct
mode functionality should not usually be mixed with other Notcurses calls.
Unlike full Notcurses, there is no explicit rendering step in direct mode, and
it is intended to be mixed among other use of standard I/O. Essentially, direct
mode ``styles your \texttt{printf()}s.'' Similarly to full Notcurses, direct mode
requires a valid and correct terminfo database entry, supplied via either the
\texttt{termtype} parameter to \texttt{notcurses\_directmode()} or the \texttt{TERM} environment
variable. It does \textit{not}, however, require any particular encoding nor
even a call to \texttt{setlocale()} (full Notcurses requires a properly-configured
ASCII or UTF-8 locale).

Enter direct mode via a call to \texttt{notcurses\_directmode()} with a successful
return of a non-\texttt{NULL} pointer to \texttt{struct ncdirect}:

\begin{listing}[!htbp]
\begin{minted}{C}
// Initialize a direct-mode notcurses context on the connected terminal at 'fp'.
// 'fp' must be a tty. You'll usually want stdout. Direct mode supportes a
// limited subset of notcurses routines which directly affect 'fp', and neither
// supports nor requires notcurses_render(). This can be used to add color and
// styling to text in the standard output paradigm. Returns NULL on error,
// including any failure initializing terminfo.
struct ncdirect* notcurses_directmode(const char* termtype, FILE* fp);
\end{minted}
\end{listing}

It is typical to invoke this function as \texttt{notcurses\_directmode(NULL, stdout)}.
In this case, the terminal type must be present in the \texttt{TERM} environment
variable (this should have been done by the terminal). The buffering and
blocking status of \texttt{fp} will not be changed. \texttt{NULL} is returned for any number
of possible errors. Otherwise, the \texttt{struct ncdirect} is ready to go, and should
be cleaned up with \texttt{ncdirect\_stop()}:

\begin{listing}[!htbp]
\begin{minted}{C}
// Release 'nc' and any associated resources. 0 on success, non-0 on failure.
int ncdirect_stop(struct ncdirect* nc);
\end{minted}
\end{listing}

Between these two calls, inject stylizing control codes into the \texttt{FILE*} with
the following API (the \texttt{stylebits} values are detailed in Chapter~\ref{sec:attribute}):

\begin{listing}[!htbp]
\begin{minted}{C}
int ncdirect_bg_rgb8(struct ncdirect* n, unsigned r, unsigned g, unsigned b);
int ncdirect_fg_rgb8(struct ncdirect* n, unsigned r, unsigned g, unsigned b);
int ncdirect_fg(struct ncdirect* n, unsigned rgb);
int ncdirect_bg(struct ncdirect* n, unsigned rgb);
int ncdirect_styles_set(struct ncdirect* n, unsigned stylebits);
int ncdirect_styles_on(struct ncdirect* n, unsigned stylebits);
int ncdirect_styles_off(struct ncdirect* n, unsigned stylebits);
int ncdirect_clear(struct ncdirect* n);
\end{minted}
\end{listing}

As detailed in Chapter~\ref{sec:channels}, the terminal has a ``default foreground color''
and ``default background color''. Use these functions to return to them.

\begin{listing}[!htbp]
\begin{minted}{C}
int ncdirect_fg_default(struct ncdirect* n);
int ncdirect_bg_default(struct ncdirect* n);
\end{minted}
\end{listing}

Direct mode allows the cursor to be moved in two-dimensional space, and
provides helpers for determining the terminal geometry. Either \texttt{y} or
\texttt{x} may be specified as -1 to maintain location on the associated axis.

\begin{listing}[!htbp]
\begin{minted}{C}
int ncdirect_dim_x(const struct ncdirect* nc);
int ncdirect_dim_y(const struct ncdirect* nc);
int ncdirect_cursor_move_yx(struct ncdirect* n, int y, int x);
\end{minted}
\end{listing}

\subsection{Example: presenting \textit{\textcolor{blue}{House} of Leaves}}

Mark Z. Danielewski's experimental 2000 novel \textit{\textcolor{blue}{House} of Leaves}\cite{danielewski2000house} prints each
instance of the word \textcolor{blue}{house} in blue, even when it is a subword:

\begin{figure}[!htbp]
\centering \includegraphics[width=.5\linewidth]{house-blue.png}
\caption{An excerpt from page 123 of \textit{\textcolor{blue}{House} of Leaves}.}
\label{fig:houseofleaves}
\end{figure}

We can easily write code to reproduce this effect for standard input and output.
Figure~\ref{fig:houseout} works as expected, but there are a few things worth noting about its code. First, observe how
much of the logic is devoted to checking and propagating errors! Perhaps
contrary to common expectation, reliable code--especially when that code's
primary effect is to write to stdout--generally needs to check the results of
e.g. \texttt{printf()} (what happens if we're redirected to a file, and
the disk is full?). A language making use of exceptions would reduce if not
eliminate this nonsense.

\begin{listing}[!htbp]
\inputminted[]{C}{code/hol-formatter.c}
\caption{\texttt{hol-formatter.c}}
\end{listing}


\begin{figure}[!htbp]
\centering \includegraphics[width=.75\linewidth]{hol-formatted.png}
\caption[\texttt{hol-formatter} as run on OCRd input.]{\texttt{hol-formatter} as run on our input. We use \texttt{tesseract} for OCR, with solid results.}
\label{fig:houseout}
\end{figure}

We don't switch from blue to some random color, because we don't know the
background color of the terminal. Hard to believe as it is, some people don't
favor a dark terminal background. If the terminal background were white, and we
had just used e.g. \texttt{ncdirect\_fg(n, 0xffffff)}, text following
``\textcolor{blue}{house}'' would be invisible.

One might observe that a user with a blue background will have invisible
``\textcolor{blue}{house}'' text. This is true, and there's no great solution
to it. It is not generally possible to discover the RGB values of the default
colors. I suppose all one can do is rest easy, serene in the belief that people
with chromatic backgrounds deserve whatever happens to them.

\subsection{Example: colorizing a dumb game}

Imagine we've written the simple guessing game in Listing~\ref{list:guessgame}.

\begin{listing}[!htbp]
\inputminted[]{C}{code/hilostdio.c}
\caption{\texttt{hilostdio.c}}
\label{list:guessgame}
\end{listing}

The correct approach for a player is binary search, and for an $N$-bit
\texttt{long}, we expect to guess the number in no more than $N$ tries. Let's
color the output to indicate how bad of a guess was offered. We'll use red for
low guesses, blue for high guesses, and break the 256 shades of each (assuming
the other two components to be fixed) uniformly across the $N$ levels of
logarithmic distance\footnote{This would be a good place to employ \gls{gamma correction}.}.
If we wanted to do this (see Listing~\ref{list:hilodirect}) without direct use of RGB color,
we'd either need accept fewer shades, or be forced to reprogram the palette.

\begin{listing}[!htbp]
\inputminted[]{C}{code/hilodirect.c}
\caption{\texttt{hilodirect.c}}
\label{list:hilodirect}
\end{listing}

Stepping through the orders of magnitude\footnote{\texttt{\_\_builtin\_clzl()}
is a compiler intrinsic for \textit{count leading zeroes}. Exhaustive methods
for fast clzl can be found in \cite{hackerdelight}. Demonstrating that
absolute value of the difference of leading zeroes is a $lg_{2}$ difference
is left as an exercise for the reader.}, we get the expected gradient
(Figure~\ref{fig:colorguess}). Were we to actually play, the response would
converge to a balanced, strong green as we approached the correct answer.

\begin{figure}[!htbp]
\centering \includegraphics[width=.75\linewidth]{media/hilodirect.png}
\caption{Colorized output from~\texttt{hilodirect.c}.}
\label{fig:colorguess}
\end{figure}

\subsection{Advanced coëxistence with stdio}
It is most common to initialize Notcurses with \texttt{stdout}, whether in
direct mode or fullscreen mode. This isn't the only way to operate, though.
By opening the tty directly using \texttt{/dev/tty}\cite{tty4}, and providing
this \texttt{FILE*} to Notcurses, a program passing its standard output to
another process can make concurrent use of Notcurses on the display, in either
direct or fullscreen mode. This is how the \texttt{notcurses-pipe} program
works\footnote{See \url{https://github.com/dankamongmen/notcurses/issues/381}.}.

For programs that need to write to the terminal, but want to ``overlay'' some
Notcurses, fullscreen mode won't work (though the program could be run in an
\texttt{ncprocess} widget; see Chapter~\ref{sec:uiwidgets}). Direct mode, however, is
a possibility. I've not yet written the example\footnote{Send me patches! Or
I'll do it\ldots eventually \url{https://github.com/dankamongmen/notcurses/issues/382}.}, but it is possible to, for
instance, periodically acquire the current cursor position, move elsewhere on
the screen, update a HUD, and return to the departure position. Scrolling could
be addressed by retaining a copy of any obliterated output. This would suffer
a startup period of one screen, during which the area scrolled above the HUD
would be cleared. This could be avoided by aligning the HUD with the top of
the terminal.

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Using fullscreen mode}
From this chapter forward, we will be using the fullscreen mode of Notcurses,
opening up all of its capabilities. This comes at a cost: while fullscreen mode
is being used, it is not safe to use standard I/O in conjunction with the
terminal controlled by Notcurses. Doing so is likely to (at a minimum) corrupt
the screen. If \texttt{stdout} and \texttt{stderr} are attached to the same
terminal (as they usually are in an interactive session), and \texttt{stdout}
is provided to Notcurses, output to \texttt{stderr} will corrupt the display
just as thoroughly as output to \texttt{stdout}. If your fullscreen Notcurses
program intends to log to \texttt{stderr}, you should first ensure that that
it has been redirected or is otherwise going somewhere different than
\texttt{stdout}. Note that simply rerendering the output will \textit{not}
necessarily clean up corruption, even following \texttt{ncplane\_erase()}
operations, since Notcurses optimizes its rendering based on its concept of the
screen. A call to \texttt{notcurses\_refresh()} will be necessary to sync the
the physical screen to Notcurses's concept thereof.

It is possible for the screen to be corrupted by external agents. For this
reason, Ctrl+L is by tradition bound to screen redrawing. You should hook this
input up to \texttt{notcurses\_refresh()} unless you have good reasons not to
do so (this is not default behavior of Notcurses only because Notcurses does
not itself read input). It is sadly not possible for such corruption to be
efficiently and generally detected.

It is possible for the attached terminal to be resized, especially (but not
only) for terminal emulators in GUI windowing environments\footnote{This could
also happen when refitting a \texttt{screen} or \texttt{tmux} session.
Even on the Linux or FreeBSD console, this can happen due to a change in video
resolution.}. Notcurses can detect such events, and synthesizes
\texttt{NCKEY\_RESIZE} inputs in response to them. If the screen shrinks, the
excess data relative to the constant origin will no longer be displayed (i.e.
the material in the upper left will be retained). If the screen is enlarged,
any data uncovered will be displayed, and the new area will otherwise be empty.
Some widgets can intelligently resize themselves in the face of screen
geometry changes (see Chapter~\ref{sec:uiwidgets}).

Notcurses prepares a given terminal for fullscreen mode in \texttt{notcurses\_init()}

\begin{listing}[!htbp]
\begin{minted}{C}
// Initialize a notcurses context on the connected terminal at 'fp'. 'fp' must
// be a tty. You'll usually want stdout. Returns NULL on error, including any
// failure initializing terminfo.
struct notcurses* notcurses_init(const notcurses_options* opts, FILE* fp);

// Destroy a notcurses instance, restoring the terminal to its original state.
int notcurses_stop(struct notcurses* nc);
\end{minted}
\end{listing}

Before calling \texttt{notcurses\_init()} (and usually as one of the first lines
of the program) it is necessary to set the current locale via the standard
library function \texttt{setlocale()}. A coverage of ANSI/ISO C locales is beyond
the scope of this text, but it is usually sufficient to call
\texttt{setlocale(LC\_ALL, "")}, relying on the user's configured \texttt{LANG}
environment variable. Notcurses only supports those locales using
US-ASCII or UTF-8 encodings (see Chapter~\ref{section:unicode} for more
information on character encodings), and its capabilities on US-ASCII
are \textit{severely} constrained. \texttt{notcurses\_init()} will return an
error for any other encoding (see Figure~\ref{fig:encodingfail}).

\begin{figure}[!htbp]
\centering \includegraphics[width=.7\linewidth]{media/notcurses-init-fails.png}
\caption{Notcurses refusing to start due to an unsupported character encoding.}
\label{fig:encodingfail}
\end{figure}

By default (assuming the \texttt{enter\_ca\_mode} terminfo capability is expressed),
Notcurses attempts to enter the ``\gls{smcup}''. Using the alternate screen
implies:
\begin{denseitemize}
\item{The screen will be cleared upon entry,}
\item{Output will not be appended to the scrollback buffer, and}
\item{On exit, output will be cleared.}
\end{denseitemize}
Whether or not the original screen contents are restored is terminal-dependent
(if the \texttt{non\_rev\_rmcup} terminfo capability is defined, the original
contents will \textit{not} be restored). This can be useful, but some users
don't like it, so it's wise to expose this via a configuration option.
Disabling use of the alternate screen can be done via the
\texttt{notcurses\_options} field \texttt{inhibit\_alternate\_screen}.

Successful creation of a \texttt{struct notcurses} implies the existence of
a \texttt{struct ncplane}, the ``standard plane''\footnote{\texttt{ncplane}s,
discussed in depth in Chapter~\ref{ncplane}, are the fundamental drawing surfaces of Notcurses.}.
This standard plane cannot be destroyed without destroying the containing
Notcurses context, nor can it be moved or resized by the user. Its size always
matches Notcurses's concept of the terminal's screen size, and its origin
always corresponds precisely to the terminal's origin. Aside from these
restrictions, the standard plane is a drawable surface like any other
\texttt{ncplane}---it can be moved along the z-axis, written to with arbitrary
glyphs and styles, made transparent, etc.

Once you're done using a \texttt{struct notcurses}, it's important to destroy
it with \texttt{notcurses\_stop()}, even if your process exits abnormally. By
default, Notcurses registers signal handlers for most fatal signals. These
handlers will call \texttt{notcurses\_stop()} and then pass the signal to the
orginal actions. You can disable this with the \texttt{no\_quit\_sighandlers}
field of \texttt{notcurses\_options}, but there aren't very many good reasons
to do so.

\subsection{The \texttt{notcurses\_options} structure}
The first parameter to \texttt{notcurses\_init()} is a (possibly \texttt{NULL})
\texttt{notcurses\_options}. This structure has been defined such that the
default options are equivalent to a zero-initialized structure. Passing \texttt{NULL}
is thus equivalent to passing a zero-initialized \texttt{notcurses\_options}.
The fields therein include:
\begin{denseitemize}
\item{\texttt{const char* termtype}: The name of the terminfo database entry to
    use. If \texttt{NULL}, the value of the environment variable \texttt{TERM}
    is used. Failure to initialize the terminfo database will result in a
    \texttt{notcurses\_init()} failure.} A defined but invalid or suboptimal
    entry will result in garbage, missing output, poor performance, reduced
    colors, and unsightly weight gain.
\item{\texttt{bool inhibit\_alternate\_screen}: As noted above, this prevents
    Notcurses from making use of the alternate screen, even if the \texttt{enter\_ca\_mode}
    terminfo capability is defined. It's best to wire this up to a user-managed
    option. Not using the alternate screen can look weird upon return to the
    shell (see Figure~\ref{fig:altscreen}).

\begin{figure}[!htbp]
\centering \includegraphics[width=.7\linewidth]{media/no-alternate-screen.png}
\caption[Inhibiting use of the alternate screen.]{\texttt{notcurses-demo} can be invoked with \texttt{-k} to avoid
  using the alternate screen. Here, we see its output left on the screen as
  we return to our shell.}
\label{fig:altscreen}
\end{figure}
  }
\item{\texttt{bool retain\_cursor}: Notcurses hides the cursor by default.
    Set this to keep the cursor visible (the cursor can be turned on and off
    at runtime with \texttt{notcurses\_cursor\_enable()} and
    \texttt{notcurses\_cursor\_disable()}).}
\item{\texttt{bool suppress\_banner}: At startup, Notcurses emits some
    diagnostics and/or warnings, including version information and details
    about the current terminal. At shutdown, it prints performance statistics.
    These outputs \textit{do not} go to the alternate screen. Set this
    field to disable these outputs, but be aware that doing so might hide
    important warnings (see Figure~\ref{fig:banner}).

    \begin{figure}[!htbp]
      \centering \includegraphics[width=.7\linewidth]{media/notcurses-banner.png}
      \caption[Notcurses initialization warnings.]{Initializing Notcurses without 24-bit color support will
        generate a warning, hopefully provoking your users to set it up.}
      \label{fig:banner}
    \end{figure}
}
\item{\texttt{bool no\_quit\_sighandlers}, \texttt{bool no\_winch\_sighandler}:
    As noted above, Notcurses by default registers signal actions for the normally fatal
    \texttt{SIGABRT}, \texttt{SIGINT}, \texttt{SIGQUIT}, and \texttt{SIGSEGV}.
    These handlers will call \texttt{notcurses\_stop()} before propagating the
    signal to the original actions. This is usually desirable, as the screen
    will not otherwise be restored to its previous state. In addition, \texttt{SIGWINCH}
    is caught in order to generate \texttt{NCKEY\_RESIZE} inputs. If you
    disable these handlers, you'll almost certainly want to replace them with
    similar functionality.}
\item{\texttt{FILE* renderfp}: If not \texttt{NULL}, this designates a file
    handle open for writing. In addition to the terminal, each rendered scene
    will be written to this file. This is intended for debugging.}
\end{denseitemize}

\subsection{Functions on \texttt{notcurses} objects}

Output is not written to this top-level \texttt{struct notcurses}---that's
done with \texttt{ncplane}s---but there are a number of functions
available for these objects. Acquiring an \texttt{ncplane} for output can be
done by grabbing a reference to the standard plane, or creating a new plane.
New planes are always inserted into the top of the z-axis. All user-created
planes can be destroyed in one call with \texttt{notcurses\_drop\_planes()} (note
that it is not necessary to call this prior to \texttt{notcurses\_stop()}; the
latter cleans up all resources associated with the context).

\begin{listing}[!htbp]
\begin{minted}{C}
// Get a reference to the standard plane (one matching our current idea of the
// terminal size) for this terminal. The standard plane always exists, and its
// origin is always at the uppermost, leftmost cell of the terminal.
struct ncplane* notcurses_stdplane(struct notcurses* nc);

// Create a new ncplane at the specified offset (relative to the standard plane)
// and the specified size. The number of rows and columns must both be positive.
// This plane is initially at the top of the z-buffer, as if ncplane_move_top()
// had been called on it. The void* 'opaque' can be retrieved (and reset) later.
struct ncplane* ncplane_new(struct notcurses* nc, int rows, int cols,
                            int yoff, int xoff, void* opaque);

// Return the topmost ncplane, of which there is always at least one.
struct ncplane* notcurses_top(struct notcurses* n);

// Destroy any ncplanes other than the stdplane.
void notcurses_drop_planes(struct notcurses* nc);
\end{minted}
\end{listing}

Reading input is a per-context operation, performed with \texttt{notcurses}
objects. It is discussed in detail in Chapter~\ref{sec:input}. When reading
input, we might get the synthesized event \texttt{NCKEY\_RESIZE}\footnote{This
event is generated upon receipt of a \texttt{SIGWINCH} signal, SIGnifying WINdow
CHange.}. This indicates that the terminal has been resized, and we ought call
\texttt{notcurses\_resize()}\footnote{Really? \textbf{FIXME} \url{https://github.com/dankamongmen/notcurses/issues/367}.}.
As discussed earlier, sometimes the display is externally corrupted. It's thus
a good idea to hook some UI event (usually Ctrl+L) to \texttt{notcurses\_refresh()},
which redraws every cell on the display according to the internal Notcurses
framebuffer.

\begin{listing}[!htbp]
\begin{minted}{C}
// Refresh our idea of the terminal's dimensions, reshaping the standard plane
// if necessary. Without a call to this function following a terminal resize
// (as signaled via SIGWINCH), notcurses_render() might not function properly.
// References to ncplanes (and the egcpools underlying cells) remain valid
// following a resize operation, but the cursor might have changed position.
int notcurses_resize(struct notcurses* n, int* restrict y, int* restrict x);

// Refresh the physical screen to match what was last rendered (i.e., without
// reflecting any changes since the last call to notcurses_render()). This is
// primarily useful if the screen is externally corrupted.
int notcurses_refresh(struct notcurses* n);
\end{minted}
\end{listing}

\begin{listing}[!htbp]
\begin{minted}{C}
// Get a human-readable string describing the running notcurses version.
const char* notcurses_version(void);
\end{minted}
\end{listing}

Finally, \texttt{notcurses\_render()} synthesizes a terminal's worth of current
state out of all your virtual objects, schedules an optimized list of escape
sequences and encoded characters, and blits the result to the terminal. Only
through \texttt{notcurses\_render()} (and transitively through its callers) ought
your program write to the actual terminal, and only \texttt{notcurses\_render()}
has any bearing on what the user sees. Between calls, you are free to do whatever
you want in terms of moving, reordering, creating, writing upon, and destroying
planes. There will be no flicker or tearing; what you last rendered remains on
the screen. When you've got your stack how you want it, and only then, invoke
\texttt{notcurses\_render()}. It is an exclusive function---any concurrent use
of the same \texttt{struct notcurses} is undefined.

\begin{listing}[!htbp]
\begin{minted}{C}
// Make the physical screen match the virtual screen. Changes made to the
// virtual screen (i.e. most other calls) will not be visible until after a
// successful call to notcurses_render().
int notcurses_render(struct notcurses* nc);
\end{minted}
\end{listing}

\subsection{Reading, rendering, rasterizing, and writing}
\label{sec:rendering}

Understanding how Notcurses translates its data structures into a terminal
display is critical for reasoning about your program in general, and particularly
relevant for maximizing performance.

During initialization of a terminal, unless \texttt{suppress\_banner} is supplied
in the \texttt{notcurses\_options}, \texttt{notcurses\_init()} will print some
diagnostics to stdout, and flush the output buffer. Notcurses maintains an
internal virtual framebuffer, containing the state of the terminal as believed
to exist\footnote{Do not confuse this with the standard plane. This framebuffer
reflects rendering and rasterizing, not the output API.}. It is initialized in
\texttt{notcurses\_init()} to an empty matrix of cells, each cell having the
default foreground and background.

What happens next depends on whether the ``alternate screen'' (as described
earlier) is employed. If so, the terminal will be immediately cleared.
Otherwise, the terminal will not be altered until the first call to
\texttt{notcurses\_render()}. That first call, however, will write to every
cell of the terminal, effectively clearing any existing output. The upshot is
that it is not possible to integrate preexisting data into your TUI, regardless
of whether the alternate screen is used. This reflects the impossibility of
portably discovering the state of the terminal.

Subsequent to the first call, Notcurses---having written them---has a concept
of the display's contents. From that point on, screen updates will write only
to changed (``damaged'') cells. When only parts of the screen have changed,
this saves a tremendous amount of work. On an 80x45 terminal, if only a 10x10
region of cells have changed, we reduce our bandwidth by about
95\%\footnote{10x10 is only 2.7\% of 80x45, but there is overhead due to moving
the cursor to the region, and then positioning the cursor at the end of each
line of the region.}. These savings are multiplicative:

\begin{denseitemize}
\item{Notcurses doesn't have to \texttt{write()} the data (memory copy).}
\item{The terminal doesn't have to \texttt{read()} the data (memory copy).}
\item{The terminal doesn't need to process the data (assorted work).}
\item{The terminal doesn't need to write to the display (memory copy).}
\end{denseitemize}

Whether a cell has been updated is decided at rasterization time. Writing to
that cell between calls to \texttt{notcurses\_render()} does not necessarily
mean the cell will be considered damaged when it comes time to write. If the
cell has been damaged, it will be emitted, and the virtual framebuffer internal
to Notcurses will be updated.

Solving for the desired state of the screen is \textit{rendering}, and this is
the first step of \texttt{notcurses\_render()}. Solving for the screen means
solving for the current state of every cell, given our ordered set of
\texttt{ncplane}s. Solving for a cell means determining the extended grapheme
cluster to be rendered, determining the attributes to be applied to that EGC,
and determining the colors in which it ought be displayed. The higher a plane
is on the z-axis, the more it can impact these solutions:

\begin{denseitemize}
\item{The EGC and attribute are determined by the first plane intersecting with
      the cell having a non-null EGC at the intersecting coordinate. If there is
    no such intersecting EGC, the EGC is null, and the attribute is
    \texttt{NCSTYLE\_NORMAL}.} Null EGCs are rendered as spaces (i.\ e.\ entirely
    background color).
\item{The foreground color is determined by the first instance of a
    \texttt{CELL\_ALPHA\_OPAQUE} foreground color, or an instance of the
    default foreground color, or an instance of a palette-indexed foreground
    color, as well as any \texttt{CELL\_ALPHA\_HIGHCONTRAST} or \texttt{CELL\_ALPHA\_BLEND}
    foreground colors encountered along the way. If there is no such intersecting
    terminator, the foreground color is the color as calculated thus far. It is
    not possible to exhaust all intersecting planes without encountering some
    influence on the foreground color, since the standard plane intersects with
    all display cells. If \texttt{CELL\_ALPHA\_HIGHCONTRAST} is in play, the
    calculated color is then blended to stand out against the calculated background
    color.}
\item{The background color is determined in the same way as the foreground color,
    except without the complicating possibility of \texttt{CELL\_ALPHA\_HIGHCONTRAST}.}
\end{denseitemize}

Once a cell is solved, Notcurses needn't continue inspecting lower planes at
that coordinate. Once all cells are solved, rendering is complete, and any
planes left over can be skipped entirely. Until then, Notcurses steps down from
one plane to the next, starting at the topmost plane, and updates its solution
for any intersecting unsolved cells. It is thus generally more performant to
``hide'' planes at the bottom of the stack, ideally behind a large opaque plane,
rather than moving them beyond the boundaries of the visible window. Likewise,
planes ought be no larger than necessary, so that they intersect with the
minimum number of cells.

Having rendered the scene, \textit{rasterization} serializes a buffer to write
to the terminal, minimizing the amount of data by moving the cursor over undamaged
regions. This is the second step of \texttt{notcurses\_render()}. Writing this
data to the terminal as it's generated is a bad idea for several reasons: it can
provoke unnecessary context switches, it results in partially-updated displays,
and it definitely involves more system calls. Notcurses instead collects it in
one or more large allocations.

Proceeding cell-by-cell from the upper left to the lower right, Notcurses
compares the rendering solution set to its internal framebuffer. If a given row
is entirely undamaged, it can be skipped. Upon discovering the leftmost damage
on a row, an absolute cursor update is performed to the damaged cell. At each
damaged cell, the EGC will be emitted, along with any necessary styling
information. It is only necessary to emit styling escapes when they change, i.\ e.\ we
can emit multiple EGCs having the same style after only issuing the appropriate
escapes once. An RGB change takes about 14 bytes, a palette index change
takes about 6, and reverting to the default 2. For single-byte simple (ASCII)
EGCs, an RGB foreground and background represent 2800\% overhead per cell!
Eliding styling escapes is thus an important secondary optimization (it's of
course most desirable to not update the cell at all).

The upshot is that holding styling constant across a horizontal stretch is
very desirable if that range's content is going to be changing. The most
pathological input to Notcurses is text that changes its foreground and background
on a cell-to-cell basis, especially when specified as RGB, that change from
render to render. Certain terminal emulators in particular respond to the
resulting deluge of RGB escapes very poorly (see Appendix~\ref{sec:termshade}).
As examples, see the \texttt{highcontrast} and \texttt{grid} demos of
\texttt{notcurses-demo}---a large \texttt{xterm} can be brought to its knees
by these routines.

Each subsequent range of undamaged cells on a line can be skipped over with
cursor movements, but as the skip length approaches 1, it becomes less and
less advantageous to do so. Rendering performance can be very roughly
categorized as inversely proportional to the product of:

\begin{denseitemize}
\item{color changes across the rendered screen,}
\item{planar depth before an opaque glyph and background are locked in,}
\item{number of UTF-8 bytes composing the rendered glyphs, and}
\item{screen geometry.}
\end{denseitemize}

With these buffers in hand, \texttt{notcurses\_render()} completes its task by
writing them to the terminal. This almost certainly means copying
them into a kernel buffer from which the terminal will then (following at
least one context switch and two system calls) read. Writing does not,
then, necessarily mean that the display has actually been updated, or even
that the terminal has read the data. If the terminal doesn't empty the buffer
quickly enough, however, you'll eventually run out of room and block. It is
thus critical to understand that \textbf{\texttt{notcurses\_render()} can block
for arbitrary amounts of time}\footnote{But see
\url{https://github.com/dankamongmen/notcurses/issues/214}.}. Furthermore,
if the terminal reads two renderings' worth of output at the same time, it is
likely to immediately enter the final state---you must not assume that a successful
\texttt{notcurses\_render()} is necessarily displayed within any arbitrary time,
or indeed that it corresponds with any displayed frame.

With those unhappy truths said, modern workstations ought have no problem pushing
notcurses onto commodity hardware at maximum framerates, with the terminal
faithfully reproducing each rendered scene. Even small microcontrollers ought
be able to render notcurses without user-perceptible latency. On a powerful
desktop with non-pathological output, it's easy to render in excess of
ten thousand frames per second, far beyond the refresh capabilities of any
existing monitor.

\subsection{Statistics}

Notcurses tracks statistics across its operation, and a snapshot can be
acquired using the \texttt{notcurses\_stats()} function. This function cannot
fail.

\begin{listing}
\begin{minted}{C}
typedef struct ncstats {
  // purely increasing stats
  uint64_t renders;          // number of successful notcurses_render() runs
  uint64_t failed_renders;   // number of aborted renders, should be 0
  uint64_t render_bytes;     // bytes emitted to ttyfp
  int64_t render_max_bytes;  // max bytes emitted for a frame
  int64_t render_min_bytes;  // min bytes emitted for a frame
  uint64_t render_ns;        // nanoseconds spent in notcurses_render()
  int64_t render_max_ns;     // max ns spent in notcurses_render()
  int64_t render_min_ns;     // min ns spent in successful notcurses_render()
  uint64_t cellelisions;     // cells we elided entirely thanks to damage maps
  uint64_t cellemissions;    // cells we emitted due to inferred damage
  uint64_t fgelisions;       // RGB fg elision count
  uint64_t fgemissions;      // RGB fg emissions
  uint64_t bgelisions;       // RGB bg elision count
  uint64_t bgemissions;      // RGB bg emissions
  uint64_t defaultelisions;  // default color was emitted
  uint64_t defaultemissions; // default color was elided

  // current state -- these can decrease
  uint64_t fbbytes;          // total bytes devoted to all active framebuffers
  unsigned planes;           // number of planes currently in existence
} ncstats;

// Acquire an atomic snapshot of the notcurses object's stats.
void notcurses_stats(struct notcurses* nc, ncstats* stats);

// Reset all cumulative stats (immediate ones, such as fbbytes, are not reset).
void notcurses_reset_stats(struct notcurses* nc, ncstats* stats);
\end{minted}
\end{listing}

Timings for renderings are across the breadth of \texttt{notcurses\_render()}:
they include all per-render preprocessing, output generation, and dumping of
the output (including any sleeping while waiting on the terminal).

\textbf{FIXME FIXME lots of duplication between here and rendering section above}

The notcurses drawing algorithm logically starts by zeroing out a
\textit{solutions array} of booleans. When this array is all true, we've solved
for each cell of the output, and can stop. It then walks down the z-axis. For
each plane encountered, any unsolved cells with which that plane interacts are
adjusted, and the solution array updated if appropriate. Note that there will
always be at least one plane interacting with each visible coordinate, due
to the default plane. The process of filling a solutions matrix is referred to
as rendering.

The next step is \textit{rasterization}. Rather than moving down the z-axis, we now
move to the right and down on the screen, starting from the upper left corner.
At each cell, we examine the solutions matrix and the previous contents of the
cell. If they are the same, no output is emitted. If they are different, the
new glyph is written to the output, following any necessary cursor movements
and styling codes. notcurses attempts to minimize the total amount of data
written by eliding unnecessary color and style specifications, and moving the
cursor over large unchanged areas.

Using the ``default color'' as only one of the foreground or background requires
emitting the \texttt{op} escape followed by the appropriate escape for changing the
fore- or background (since \texttt{op} changes both at once).

Certain EGCs are understood to be all-foreground or all-background.
\texttt{U+2588 FULL BLOCK} is all foreground. \texttt{U+0020 SPACE} is all
background. When such a character is used, notcurses will emit whichever
character can take advantage of the current color.

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{simpleloop.tex}
\pagebreak
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The mechanics of a tty}
\label{section:tty}
\textbf{FIXME FIXME acquisition of a tty (getty->login, ssh->pty),
  internals of kernel tty/pty devices, session groups, signal distribution,
  \texttt{/dev/tty} and \texttt{/dev/ttyXX}s}
\textbf{FIXME FIXME other stuff}
\subsection{Escape codes ANSI and otherwise}
\label{sec:escapes}
My diagrams are adapted in part from those of Linus Akesson\cite{ttydemystified}.
\textbf{FIXME diagrams!}

In a relic from teletypes, ISO 646, ISO 2022, and ECMA-35 described use of
non-destructive backspace to produce composed characters from spacing ones.
This had been eliminated by ISO 4873, ECMA-43, and ISO 8859.

\textbf{FIXME FIXME other stuff}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Character encodings and glyphs}
\label{section:unicode}
We'll be well-served by becoming familiar with our core building
blocks---character sets and their rasterized forms. Even if we were to shrink
the character cell to a single pixel, we'd still need write one or another
character into it, and emit a control code to stylize it\footnote{I've seen
this idea bandied about as if it's a serious suggestion. Besides the fact
that it won't work in a console, escapes are \textit{far} less efficient than
canvases or OpenGL display lists; if your plan involves using ANSI escape
sequences to drive a 1920x1080 display via roughly two million 1x1 character
cells, you're not going to space today, or maybe ever\cite{upgoerfive}.}.

In the early 1960s, an IBM employee on a dare ate a hallucinogenic tapeworm
that pissed nitric acid. Stuffing his steaming, rapidly decoiling bowels
up into a brown paper bag, he was off to the hospital. Alas! On those very
hospital steps he was struck by lightning, and filled with spears, and
set upon by savage hogs, and finally exploded. The tapeworm emerged, clad
in shimmering mandorla, with a name pronounceable in no human tongue. ``Adding
hallucinogenic tapeworms to a late project only makes it later,'' Brooks
cautioned\cite{mythicalman}, but Gene Amdahl knew no peace. ``This
Tapeworm Queen reminds me of my Wisconsin days!'' he cried, and on a prototype
Model 30 appeared her Name. Struck by the power of that Name, all began to bow,
and to weep. She vomited forth the Tapeworm Gospel. Looking upon this filth, they
thought it Good.

So now you know what EBCDIC is. We will speak of it no further\footnote{If you
find yourself needing more information about EBCDIC, it might be time to think long and hard about your life decisions.}.

For our purposes, the story can reasonably start with a 7-bit encoding of
128 characters: ANSI X3.4-1986, perhaps better known as ASCII (Table~\ref{table:ascii}).
The first ASCII we would recognize as such\footnote{ASCII-1963 was caveperson ASCII. In the words of
 G.H. Hardy, ``ASCII-1963 was clever schoolboys; '68 was a Fellow from another
College\cite{ghhardy}.''} was the unpublished ASCII-1965. ASCII-1968 was
released as USAS X3.4-1968 to wild acclaim. The ISO/IEC 646 standard
``internationalized'' ASCII-1968. \textbf{FIXME\ldots}

The first 32 values are non-printable control codes, known as the ``C0''
control set.

\begin{table}
  \centering
  \begin{tabular}{ |c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c| }
    \hline
    & x0 & x1 & x2 & x3 & x4 & x5 & x6 & x7 & x8 & x9 & xa & xb & xc & xd & xe & xf \\
    \hline
    0x & NUL & SOH & STX & ETX & EOT & ENQ & ACK & BEL & BS & HT & LF & VT & FF & CR & SO & SI \\
    \hline
    1x & DLE & DC1 & DC2 & DC3 & DC4 & NAK & SYN & ETB & CAN & EM & SUB & ESC & FS & GS & RS & US \\
    \hline
    2x & SP & ! & " & \# & \$ & \% & \& & ' & ( & ) & * & + & , & - & . & / \\
    \hline
    3x & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & : & ; & < & = & > & ? \\
    \hline
    4x & $@$ & A & B & C & D & E & F & G & H & I & J & K & L & M & N & O \\
    \hline
    5x & P & Q & R & S & T & U & V & W & X & Y & Z & [ & \ & ] & \^ & \_ \\
    \hline
    6x & \` & a & b & c & d & e & f & g & h & i & j & k & l & m & n & o \\
    \hline
    7x & p & q & r & s & t & u & v & w & x & y & z & \{ & | & \} & $~$ & DEL \\
    \hline
  \end{tabular}
  \caption{ANSI X3.4-1986 (ASCII, IA5, T.50 IRA, RFC 20).}
  \label{table:ascii}
\end{table}

\subsection{The Universal Character Set}
\begin{center}
\includegraphics[width=.9\linewidth]{media/charset-timeline.png}
\end{center}

\textbf{FIXME FIXME graph of unicode character count by version}

\footnote{Once upon a time, these other sixteen planes were known as the
  Astral Planes\cite{astralplanes}.}
\subsection{UTF-8}
\subsection{Stupid Unicode tricks}
\textbf{FIXME} cyclic groups, reversals, zalgo, \url{http://qaz.wtf/u/}

\subsection{Fixed-width fonts ain't so fixed}

Notcurses assumes that all glyphs occupy widths which are an integral multiple
of the smallest possible glyph's cell width (aka a ``fixed-width font'').
Unicode introduces characters which generally occupy two such cells, known as
wide characters (though in the end, width of a glyph is a property of the
font). It is not possible to print half of such a glyph, nor is it generally
possible to print a wide glyph on the last column of a terminal.

Notcurses does not consider it an error to place a wide character on the last
column of a line. It will obliterate any content which was in that cell, but
will not itself be rendered. The default content will not be reproduced in such
a cell, either. When any character is placed atop a wide character's left or
right half, the wide character is obliterated in its entirety. When a wide
character is placed, any character under its left or right side is annihilated,
including wide characters. It is thus possible for two wide characters to sit
at columns 0 and 2, and for both to be obliterated by a single wide character
placed at column 1.

Likewise, when rendering, a plane which would partially obstruct a wide glyph
prevents it from being rendered entirely. A pathological case would be that of
a terminal $n$ columns in width, containing $n-1$ planes, each 2 columns wide.
The planes are placed at offsets $[0\ldots n-1]$. Each plane is above the plane to
its left, and each plane contains a single wide character. Were this to be
rendered, only the rightmost plane (and its single glyph) would be rendered!

\begin{listing}[!htbp]
\begin{minted}{C}
// Calculate the size in columns of the provided UTF8 multibyte string.
int mbswidth(const char* mbs);
\end{minted}
\end{listing}


\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Using ncplanes}
\label{ncplane}
\subsection{Moving and resizing planes}
\subsection{Cells, strings, and formatted output}
\subsection{Alpha blending and plane transparency}
%\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Styling with colors and attributes}
\subsection{The 32-bit \texttt{attribute} value}
\label{sec:attribute}
\subsection{The 64-bit \texttt{channels} value}
\label{sec:channels}
%\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Lines, boxes, and fills}
\subsection{Linear interpolation (``lerping'') and gradients}
\subsection{Blitting}
\subsection{Staining}
\label{sec:staining}
\begin{listing}[!htbp]
\begin{minted}{C}
// Set the given style throughout the specified region, keepying content and
// channels otherwise unchanged.
int ncplane_format(struct ncplane* n, int ystop, int xstop, uint32_t attrword);

// Set the given channels throughout the specified region, keepying content and
// attributes otherwise unchanged.
int ncplane_stain(struct ncplane* n, int ystop, int xstop, uint64_t ul,
                  uint64_t ur, uint64_t ll, uint64_t lr);

// Replace the EGC underneath us, but retain the styling. The current styling
// of the plane will not be changed.
int ncplane_putsimple_stainable(struct ncplane* n, char c);

// Replace the EGC underneath us, but retain the styling. The current styling
// of the plane will not be changed.
int ncplane_putegc_stainable(struct ncplane* n, const char* gclust, int* sbytes);

// Replace the EGC underneath us, but retain the styling. The current styling
// of the plane will not be changed.
int ncplane_putwegc_stainable(struct ncplane* n, const wchar_t* gclust, int* sbytes);
\end{minted}
\label{list:stain}
\end{listing}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Collecting and dispatching input}
\label{sec:input}

\textbf{FIXME FIXME FIXME}

\begin{listing}[!htbp]
\begin{minted}{C}
// See ppoll(2) for more detail. Provide a NULL 'ts' to block at length, a 'ts'
// of 0 for non-blocking operation, and otherwise a timespec to bound blocking.
// Signals in sigmask (less several we handle internally) will be atomically
// masked and unmasked per ppoll(2). It should generally contain all signals.
// Returns a single Unicode code point, or (char32_t)-1 on error. 'sigmask' may
// be NULL. Returns 0 on a timeout. If an event is processed, the return value
// is the 'id' field from that event. 'ni' may be NULL.
char32_t notcurses_getc(struct notcurses* n, const struct timespec* ts,
                        sigset_t* sigmask, ncinput* ni);

// 'ni' may be NULL if the caller is uninterested in event details. If no event
// is ready, returns 0.
static inline char32_t
notcurses_getc_nblock(struct notcurses* n, ncinput* ni){
  sigset_t sigmask;
  sigfillset(&sigmask);
  struct timespec ts = { .tv_sec = 0, .tv_nsec = 0 };
  return notcurses_getc(n, &ts, &sigmask, ni);
}

// 'ni' may be NULL if the caller is uninterested in event details. Blocks
// until an event is processed or a signal is received.
static inline char32_t
notcurses_getc_blocking(struct notcurses* n, ncinput* ni){
  sigset_t sigmask;
  sigemptyset(&sigmask);
  return notcurses_getc(n, NULL, &sigmask, ni);
}

// Enable the mouse in "button-event tracking" mode with focus detection and
// UTF8-style extended coordinates. On failure, -1 is returned. On success, 0
// is returned, and mouse events will be published to notcurses_getc().
int notcurses_mouse_enable(struct notcurses* n);

// Disable mouse events. Any events in the input queue can still be delivered.
int notcurses_mouse_disable(struct notcurses* n);
\end{minted}
\end{listing}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Multimedia (images and videos)}
\label{sec:libav}

Media decoding and scaling is handled by libAV from FFmpeg, resulting in a
\texttt{notcurses\_visual} object. This object generates frames, each one
corresponding to a renderable scene on the associated plane. If Notcurses
is built without FFMpeg support, these functions will all return error.

\begin{listing}
\begin{minted}{C}
// Open a visual (image or video), associating it with the specified ncplane.
// Returns NULL on any error, writing the AVError to 'averr'.
struct ncvisual* ncplane_visual_open(struct ncplane* nc, const char* file,
                                     int* averr);

// Destroy an ncvisual. Rendered elements will not be disrupted, but the visual
// can be neither decoded nor rendered any further.
void ncvisual_destroy(struct ncvisual* ncv);

// Render the decoded frame to the associated ncplane. The frame will be scaled
// to the size of the ncplane per the ncscale_e style. A subregion of the
// frame can be specified using 'begx', 'begy', 'lenx', and 'leny'. To render
// the rectangle formed by begy x begx and the lower-right corner, zero can be
// supplied to 'leny' and 'lenx'. Zero for all four values will thus render the
// entire visual. Negative values for any of the four parameters are an error.
// It is an error to specify any region beyond the boundaries of the frame.
int ncvisual_render(const struct ncvisual* ncv, int begy, int begx, int leny, int lenx);

// Return the plane to which this ncvisual is bound.
struct ncplane* ncvisual_plane(struct ncvisual* ncv);

// If a subtitle ought be displayed at this time, return a heap-allocated copy
// of the UTF8 text.
char* ncvisual_subtitle(const struct ncvisual* ncv);
\end{minted}
\end{listing}

\subsection{Streaming video/animated GIFs.}
\begin{listing}
\begin{minted}{C}
// Called for each frame rendered from 'ncv'. If anything but 0 is returned,
// the streaming operation ceases immediately, and that value is propagated out.
typedef int (*streamcb)(struct notcurses* nc, struct ncvisual* ncv, void*);

// Shut up and display my frames! Provide as an argument to ncvisual_stream().
// If you'd like subtitles to be decoded, provide an ncplane as the curry. If the
// curry is NULL, subtitles will not be displayed.
static inline int
ncvisual_simple_streamer(struct notcurses* nc, struct ncvisual* ncv, void* curry){
  if(notcurses_render(nc)){
    return -1;
  }
  int ret = 0;
  if(curry){
    // need a cast for C++ callers
    struct ncplane* subncp = (struct ncplane*)curry;
    char* subtitle = ncvisual_subtitle(ncv);
    if(subtitle){
      if(ncplane_putstr_yx(subncp, 0, 0, subtitle) < 0){
        ret = -1;
      }
      free(subtitle);
    }
  }
  return ret;
}

// Stream the entirety of the media, according to its own timing. Blocking,
// obviously. streamer may be NULL; it is otherwise called for each frame, and
// its return value handled as outlined for stream cb. Pretty raw; beware.
// If streamer() returns non-zero, the stream is aborted, and that value is
// returned. By convention, return a positive number to indicate intentional
// abort from within streamer(). 'timescale' allows the frame duration time to
// be scaled. For a visual naturally running at 30FPS, a 'timescale' of 0.1
// will result in 300FPS, and a 'timescale' of 10 will result in 3FPS. It is an
// error to supply 'timescale' less than or equal to 0.
int ncvisual_stream(struct notcurses* nc, struct ncvisual* ncv, int* averr,
                    float timescale, streamcb streamer, void* curry);
\end{minted}
\end{listing}

\subsection{Scaling images and video}
\begin{listing}
\begin{minted}{C}
// How to scale the visual in ncvisual_open_plane(). NCSCALE_NONE will open a
// plane tailored to the visual's exact needs, which is probably larger than the
// visible screen (but might be smaller). NCSCALE_SCALE scales a visual larger
// than the visible screen down, maintaining aspect ratio. NCSCALE_STRETCH
// stretches and scales the image in an attempt to fill the visible screen.
typedef enum {
  NCSCALE_NONE,
  NCSCALE_SCALE,
  NCSCALE_STRETCH,
} ncscale_e;

// Open a visual, extract a codec and parameters, and create a new plane
// suitable for its display at 'y','x'. If there is sufficient room to display
// the visual in its native size, or if NCSCALE_NONE is passed for 'style', the
// new plane will be exactly that large. Otherwise, the plane will be as large
// as possible (given the visible screen), either maintaining aspect ratio
// (NCSCALE_SCALE) or abandoning it (NCSCALE_STRETCH).
struct ncvisual* ncvisual_open_plane(struct notcurses* nc, const char* file,
                                     int* averr, int y, int x, ncscale_e style);
\end{minted}
\end{listing}

\subsection{Sprites}
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{UI widgets}
\label{sec:uiwidgets}
\subsection{Selectors and multiselectors}

The selector widget is an ncplane with a body section and optional title riser.
The body section is populated with options and descriptions, and supports
infinite scrolling up and down. The widget is automatically sized according to
the largest input provided. The keyboard and mouse wheel can scroll through
selections, and clicking on the arrows also scrolls. Selection and cancellation
are implemented by the caller. The currently-selected option can be retrieved
at any time. Option/description pairs can be added or removed while the
widget is active, even if the removed pair is currently selected. Removing the
last pair does not destroy the widget, and it is possible to create the widget
with no pairs.

\begin{listing}[!htbp]
\begin{minted}{C}
struct selector_item {
  char* option;
  char* desc;
};

typedef struct selector_options {
  char* title; // title may be NULL, inhibiting riser, saving two rows.
  char* secondary; // secondary may be NULL
  char* footer; // footer may be NULL
  struct selector_item* items; // initial items and descriptions
  unsigned itemcount; // number of initial items and descriptions
  // default item (selected at start), must be < itemcount unless 'itemcount'
  // is 0, in which case 'defidx' must also be 0
  unsigned defidx;
  // maximum number of options to display at once, 0 to use all available space
  unsigned maxdisplay;
  // exhaustive styling options
  uint64_t opchannels;   // option channels
  uint64_t descchannels; // description channels
  uint64_t titlechannels;// title channels
  uint64_t footchannels; // secondary and footer channels
  uint64_t boxchannels;  // border channels
  uint64_t bgchannels;   // background channels, used only in body
} selector_options;

struct ncselector* ncselector_create(struct ncplane* n, int y, int x,
                                     const selector_options* opts);
\end{minted}
\end{listing}

\begin{figure}
    \centering
    \includegraphics[width=.75\linewidth]{media/selector1.png}
    \caption{Selector with a long title.}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=.75\linewidth]{media/selector2.png}
    \caption{Short title intersecting with header.}
\end{figure}

\begin{figure}
  \centering \includegraphics[width=.75\linewidth]{media/selector3.png}
    \caption{Selector with a long header.}
\end{figure}

\begin{figure}
\centering \includegraphics[width=.75\linewidth]{media/selector4.png}
\caption{Selector with a long footer and no header.}
\end{figure}

\begin{figure}
  \centering \includegraphics[width=.75\linewidth]{media/selector5.png}
  \caption{Naked selector.}
\end{figure}

\begin{listing}[!htbp]
\begin{minted}{C}
int ncselector_additem(struct ncselector* n, const struct selector_item* item);
int ncselector_delitem(struct ncselector* n, const char* item);

// Return a reference to the selected option, or NULL if there are no items.
const char* ncselector_selected(const struct ncselector* n);

// Return a reference to the ncselector's underlying ncplane.
struct ncplane* ncselector_plane(struct ncselector* n);

// Move up or down in the list. A reference to the newly-selected item is
// returned, or NULL if there are no items in the list.
const char* ncselector_previtem(struct ncselector* n);
const char* ncselector_nextitem(struct ncselector* n);

// Offer the input to the ncselector. If it's relevant, this function returns
// true, and the input ought not be processed further. If it's irrelevant to
// the selector, false is returned. Relevant inputs include:
//  * a mouse click on an item
//  * a mouse scrollwheel event
//  * a mouse click on the scrolling arrows
//  * a mouse click outside of an unrolled menu (the menu is rolled up)
//  * up, down, pgup, or pgdown on an unrolled menu (navigates among items)
bool ncselector_offer_input(struct ncselector* n, const struct ncinput* nc);

// Destroy the ncselector. If 'item' is not NULL, the last selected option will
// be strdup()ed and assigned to '*item' (and must be free()d by the caller).
void ncselector_destroy(struct ncselector* n, char** item);
\end{minted}
\end{listing}

\subsection{Menus}

Horizontal menu bars are supported on the top and bottom rows of planes. If a
menu bar is longer than the bound plane, it will be only partially visible, but
any unrolled section will be visible. Menus may be either visible or invisible
by default. Set the `hiding` option to get an invisible menu. In the event of a
screen resize, menus will be automatically moved/resized.

\begin{listing}[!htbp]
\begin{minted}{C}
typedef struct menu_options {
  bool bottom;              // on the bottom row, as opposed to top row
  bool hiding;              // hide the menu when not being used
  struct {
    char* name;             // utf-8 c string
    struct {
      char* desc;           // utf-8 menu item, NULL for horizontal separator
      ncinput shortcut;     // shortcut, all should be distinct
    }* items;
    int itemcount;
  }* sections;              // array of menu sections
  int sectioncount;         // must be positive
  uint64_t headerchannels;  // styling for header
  uint64_t sectionchannels; // styling for sections
} menu_options;

struct ncmenu;

// Create a menu with the specified options. Menus are currently bound to an
// overall notcurses object (as opposed to a particular plane), and are
// implemented as ncplanes kept atop other ncplanes.
struct ncmenu* ncmenu_create(struct notcurses* nc, const menu_options* opts);
\end{minted}
\end{listing}

\begin{figure}
    \centering
    \includegraphics[width=.75\linewidth]{media/menutop.png}
    \caption{Menu along the top of the standard plane.}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=.75\linewidth]{media/menubottom.png}
    \caption{Menu along the bottom of the standard plane.}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=.75\linewidth]{media/menuwarmech.png}
    \caption[WarMECH and a translucent menu.]{The \texttt{notcurses-demo} menu, unrolled \textit{in media res}. Luigi, pursued
      by WarMECH, is leaping through the ``Help'' menu. In the upper left is the HUD,
      and at the bottom the About text, both implemented as translucent planes.}
\end{figure}

\begin{listing}[!htbp]
\begin{minted}{C}
// Unroll the specified menu section, making the menu visible if it was
// invisible, and rolling up any menu section that is already unrolled.
int ncmenu_unroll(struct ncmenu* n, int sectionidx);

// Roll up any unrolled menu section, and hide the menu if using hiding.
int ncmenu_rollup(struct ncmenu* n);

// Return the selected item description, or NULL if no section is unrolled. If
// 'ni' is not NULL, and the selected item has a shortcut, 'ni' will be filled
// in with that shortcut--this can allow faster matching.
const char* ncmenu_selected(const struct ncmenu* n, struct ncinput* ni);

// Return the ncplane backing this ncmenu.
struct ncplane* ncmenu_plane(struct ncmenu* n);

// Offer the input to the ncmenu. If it's relevant, this function returns true,
// and the input ought not be processed further. If it's irrelevant to the
// menu, false is returned. Relevant inputs include:
//  * mouse movement over a hidden menu
//  * a mouse click on a menu section (the section is unrolled)
//  * a mouse click outside of an unrolled menu (the menu is rolled up)
//  * left or right on an unrolled menu (navigates among sections)
//  * up or down on an unrolled menu (navigates among items)
//  * escape on an unrolled menu (the menu is rolled up)
bool ncmenu_offer_input(struct ncmenu* n, const struct ncinput* nc);

// Destroy a menu created with ncmenu_create().
int ncmenu_destroy(struct ncmenu* n);
\end{minted}
\end{listing}

\subsection{Reels}
\subsection{Example: let's rip off \texttt{whiptail}}

\section{Hack the Planet!}
\subsection{Example: let's rip off tetris}
\label{section:casestudy}
\subsection{Example: walking through \texttt{notcurses-demo}}
The \texttt{notcurses-demo} program is built as part of Notcurses, and ought
have been installed alongside the library (on Debian, you'll need the
\texttt{notcurses-bin} package, and even then the demo has been somewhat
reduced in order to comply with the DFSG\cite{dfsg}). It demonstrates a wide
range of Notcurses capabilities, and its source code is most instructive.

It is best to run the demo in a terminal having geometry of at least 80x45,
though anything 80x24 or larger will more or less work (some content will be
clipped). It is also desirable to have 24-bit color enabled, assuming your
terminal supports it. Determine the number of colors advertised by your
terminal type using~\texttt{infocmp} (see Figure~\ref{fig:terminfocmp}).
Some relevant terminfo capabilities are described in Table~\ref{table:terminfo}.

\begin{table}[h]
  \begin{center}
    \begin{tabular}{ |c|c|c| }
      \hline
      \texttt{colors} & Integer & Number of colors. \\
      \hline
      \texttt{ccc} & Boolean & The palette can be programmed. \\
      \hline
      \texttt{RGB} & Boolean & Direct RGB values can be speficied. \\
      \hline
    \end{tabular}
  \end{center}
  \caption{Relevant terminfo properties.}
  \label{table:terminfo}
\end{table}

Each demo makes use of a few different Notcurses capabilities. In addition,
a menu is present throughout. From this menu (or using keyboard shortcuts),
you can activate a HUD (H) and an informational help display (Ctrl+u). In
addition, you can restart the demo with Ctrl+R, or quit at any time (q). This
application serves admirably for benchmarking certain terminal behaviors, and
we'll do exactly that in Appendix~\ref{sec:termshade}. The performance
properties of various components are described at length therein.

\begin{figure}[h]
  \centering
  \includegraphics[width=.75\linewidth]{media/terminfocmp.png}
  \caption{Inspecting the terminfo database.}
  \label{fig:terminfocmp}
\end{figure}

Screenshots were taken using \texttt{scrot} 1.2 and a 80x45
\texttt{xfce4-terminal} 0.8.9.1 from Xfce 4.14+Compiz 0.8.16.1 atop Xorg
1.20.7 on NVIDIA 440.59. All of these are the unmodified Debian Unstable
x86\_64 binaries. My kernel is a custom 5.5.6 build. The terminal type is
\texttt{xterm-256color}, and \texttt{COLORTERM} is defined to be
\texttt{24bit}.

\newpage

\begin{figure}
  \centering
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-intro.png}
    \caption[``Intro''.]{``Intro''. Lerps on the perimeters. Inverse radial
            gradient plus vertical gradient. Full-screen fade.
            Cyclic glyphs. Italics.}
  \end{minipage}\hfill
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-xray.png}
    \caption[``X-Ray''. Very large planes.]{``X-Ray''. Streaming video.
       Very large planes (the scrolling plane at the bottom is much larger than the visible screen).}
  \end{minipage}
\end{figure}

\begin{figure}
  \centering
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demoeagle2.png}
    \caption{``Eagle'', first phase.\\
      Parallax scrolling on large image.}
  \end{minipage}\hfill
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demoeagle1.png}
    \caption{``Eagle'', second phase.\\
      Sprites. Zoomed image.}
  \end{minipage}
\end{figure}

\begin{figure}
  \centering
  \begin{minipage}{0.30\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-trans1.png}
    \caption[``Trans'', early phase.]{``Trans''. Transparent top plane. Window through to the desktop.}
  \end{minipage}\hfill
  \begin{minipage}{0.30\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-trans2.png}
    \caption[``Trans'', middle phase.]{``Trans''. Opaque foreground, transparent background, no glyph.}
  \end{minipage}\hfill
  \begin{minipage}{0.30\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-trans3.png}
    \caption[``Trans'', late phase.]{``Trans''. Transparent foreground and background with opaque glyph.}
  \end{minipage}\hfill
\end{figure}

\begin{figure}
  \centering
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-highcon.png}
    \caption{``Highcon''. High-contrast text.}
  \end{minipage}\hfill
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-grid.png}
    \caption{``Grid''. Max RGB density.}
  \end{minipage}\hfill
\end{figure}

\begin{figure}
  \centering
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-box.png}
    \caption{``Box''. Lerped perimeters. Precise Unicode. Color sweeps.}
  \end{minipage}\hfill
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-sliders.png}
    \caption{``Sliders''. Partial fades. Animation. Gradients.}
  \end{minipage}\hfill
\end{figure}

\begin{figure}
  \centering
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-reels.png}
    \caption{``Reels''. The \texttt{ncreel} widget.}
  \end{minipage}\hfill
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-whiteout.png}
    \caption{``Whiteout''. Translucency.}
  \end{minipage}\hfill
\end{figure}

\begin{figure}
  \centering \includegraphics[width=.75\linewidth]{media/demo-chunli1.png}
  \caption{``Chunli''. Sprite animation.}
\end{figure}

\begin{figure}
  \centering \includegraphics[width=.75\linewidth]{media/demo-chunli2.png}
  \caption{``Chunli''. Sprite animation.}
\end{figure}

\begin{figure}
  \centering
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-uniblock1.png}
    \caption{``Uniblock''. Hangul syllables.}
  \end{minipage}\hfill
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-uniblock2.png}
    \caption{``Uniblock''. Emoji.}
  \end{minipage}\hfill
\end{figure}

\begin{figure}
  \centering
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-img1.png}
    \caption{``View''. Scaling an image.}
  \end{minipage}\hfill
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-img2.png}
    \caption{``View''. Transparent images.}
  \end{minipage}\hfill
\end{figure}

\begin{figure}
  \centering
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-view1.png}
    \caption{``View''. Streaming video with high-contrast text.}
  \end{minipage}\hfill
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-view2.png}
    \caption{``View''. Notice the high-contrast kicking in.}
  \end{minipage}\hfill
\end{figure}

\begin{figure}
  \centering \includegraphics[width=1\linewidth]{media/demojungle.png}
  \caption[``Jungle''. Palette-indexed image.]{``Jungle''. Palette-indexed image. Very low-bandwidth animation via palette cycling.\\
    ``Ruins in Rain'' © Mark Ferrari/Living Worlds. Texelized with permission.}
\end{figure}


\begin{figure}
  \centering
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-fallin1.png}
    \caption[``Fallin\''', early phase.]{``Fallin\'''. Color change, introspection, many planes.}
  \end{minipage}\hfill
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-fallin2.png}
    \caption[``Fallin\''', late phase.]{``Fallin\'''. The underlying image is revealed.}
  \end{minipage}\hfill
\end{figure}

\begin{figure}
  \centering
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-luigi.png}
    \caption{``Luigi''. Multiple sprites.}
  \end{minipage}\hfill
  \begin{minipage}{0.45\textwidth}
    \includegraphics[width=1\linewidth]{media/demo-outro.png}
    \caption{``Outro''. Fades atop video.}
  \end{minipage}\hfill
\end{figure}

\clearpage
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{appendices}
\section{A brief history of character graphics}
\label{sec:terminals}
The earliest terminals making use of glyphs\footnote{Konrad Zuse's Z3, generally
 considered the first programmable digital computer, communicated with its
operator through a matrix of blinkenlights and a not unsteampunkish keyboard that resembled the
Burroughs typewriters of its era\cite{zuse}.} printed them to paper, and are of
interest to us only so far as our modern term ``tty'' is rather dubiously
derived from ``TeleTYpewriter'', as these cantankerous contraptions were
known\footnote{Though we do hear of their Snoopy calendars in the songs of
legend\cite{quiche}.} (people had less experience abbreviating in those days).

These devices most typically printed 72 characters per line (CPL), a limit that
has persisted in strange places\cite{pandoc} through the modern era. Another constant
you'll see from time to time is 132 CPL, derived from line printers such as the
IBM 1403, the DEC LP11, and the Centronics 101\cite{ibm1403}. Most common,
however, is the 80 column line originating in 1928's 7¾x3¼x0.007in IBM
Computer Card (as designed by Clair D.\ Lake, deriving from the 1890 U.\ S.\
Census cards of Herman Hollerith\ldots themselves borrowing from Joseph
Jacquard's automation in 1804 of punched card loom control technology pioneered
by Basile Bouchon in 1725\cite{cards}). To this day, so long as your wacky
output device can do 80 columns, eh, that's good enough. In all these cases,
the limit arises from the number of characters that could be printed, using the
technology of the time, on their feeder paper (8.5in and 14in in the case of
printers).

On, then, to the ``Glass TTYs'' (ugh) and Visual Display Units of the 1970s.
Pictured in Figure~\ref{fig:terminals} are the Computer Terminal Corporation
Datapoint 3300, the Lear Sigler, Inc.\ ADM-3A, the Hazeltine 1500, and the
Soroc IQ-120. Lacking microcontrollers, and generally implementing no
independent control sequences, such devices are today often known as ``dumb
terminals'' (this term was originally a registered trademark of Lear Sigler,
see below). Already the 80x24 ``standard'' (it is not a standard) was emerging
(the DEC contemporaries listed were already pretty ``smart'', using proprietary
control codes):

\begin{table}[h]
\begin{center}
  \begin{tabular}{ |c|c|c| }
    \hline
    IBM 2260 Model 1 & 1965 & 40x6 \\
    \hline
    Datapoint 3300 & 1969 & 72x25 \\
    \hline
    DEC VT05 & 1970 & 72x24 \\
    \hline
    IBM 3277 Model 2 & 1971 & 80x24 \\
    \hline
    Textronix 4010 & 1972 & 74x35 \\
    \hline
    DECscope VT52 & 1974 & 80x24 \\
    \hline
    LSI ADM-3A & 1976 & 80x12, 80x24 \\
    \hline
    Hazeltine 1500 & 1977 & 80x24 \\
    \hline
    Sororc IQ-120 & 1977 & 80x24 \\
    \hline
  \end{tabular}
\caption{Some historical terminals and their resolutions.}
\end{center}
\end{table}

Why 80x24 (or 80x25, as you'll also see)\cite{infoworld80}? The 80 almost certainly arises from
the desire to display an entire punched card (this \textit{is} a standard---see
ANSI X3.21-1967/FIPS PUB 13, ``Rectangular Holes in Twelve-Row Punched
Cards'')\cite{sonicdelay}. The origin of 24 is less clear. 24 is highly
composite (it has more divisors than any smaller number), and it is the largest
integer divisible by all natural numbers not larger than its square root. There
are of course 24 hours in a day. 24 divides the scanline counts of both NTSC
and PAL at 480 and 576, respectively. 24 rows of 80 columns at a byte per
column utilize 93.75\% of a 2KiB memory, leaving exactly 128 bytes left over,
and everyone loves a good power of 2.

The Aaronites, Levite descendents of Moses's brother Aaron, the first
\texthebrew{כהן גדול}
(High Priest),
form the priestly \texthebrew{כֹּהֲנִים}; they were divided into 24 courses. The Buddha's Dharma Chakra (Wheel of Dhamma)
in its Ashoka form sends forth 24 spokes. But perhaps I grow esoteric, and even
speculative\ldots in truth, 80x24 almost certainly owes its questionable
existence to IBM's punched cards, IBM 2260 and 3270 wanting compatibility with
IBM printers, the upstart DEC wanting compatibility with IBM software for their
VT52 and legendary VT100, and the VT100 subsequently becoming a \textit{de facto} standard for
four decades.

\begin{figure}
  \centering \includegraphics[width=.9\linewidth]{media/dumbterminals.jpg}
\caption[Dumb terminals of the 1970s.]{Clockwise starting from upper left: a dork and his LSI ADM (``American
  Dream Machine'', supposedly). That poor woman with the Sororc IQs looks stoned out
  of her gourd. Grizzly Adams rocks a Datapoint 3300, but really his mind is on
  seeing Skynyrd shred it this weekend. Finally, we have Frank the Cocaine
  Ranger and his Electric Hazeltine 1500 Band. \textit{Gott im Himmel}, the 70s were \textit{unseemly}.}
\label{fig:terminals}
\end{figure}

\begin{figure}
  \begin{minipage}{0.5\textwidth}
  \centering
    \includegraphics[width=.5\linewidth]{media/digital-terms.jpeg}
    \caption{Digital Equipment Corporation terminals of the 1970s and 1980s.}
  \end{minipage}\hfill
  \begin{minipage}{0.4\textwidth}
  \centering
    \includegraphics[width=.45\linewidth]{media/vt220-charset.png}
    \caption[VT220 glyph dump.]{The VT220's glyphs from a ROM dump. VT100 implemented most of the
      first seven columns. Note the existence of box-drawing characters\cite{crttypography}.}
  \end{minipage}\hfill
\end{figure}

\subsection{The DEC VTxxx terminals and ANSI X3.64-1979}

Introduced in August 1978, the VT100 ushered in a new era of smart terminals
using commodity (Intel) microprocessors, implementing portions of the upcoming
ANSI X3.64 standard (itself based on 1976's first edition of ECMA-48) along
with DEC extensions\footnote{The VT100 \textit{did not} implement all of X3.64,
nor was X3.64 derived from the VT100. The VT100 didn't do color, nor did it
insert or delete lines. It furthermore implemented several features outside
the scope of ECMA-48's first edition.} This series would go on to sell over
six million units, and it was a rare vendor that didn't include some degree
of DEC VT compatibility. Each major iteration of the series was designed to
encompass all functionality of prior iterations, beginning with the VT100's
faithful emulation of the earlier era's VT52. The VT102 cut down on the cost
and size of the VT100, and included the 132-CPL mode by default; they were
otherwise essentially the same device\cite{vt100}.

The original \texttt{xterm} was written as an emulator of the VAXStation 100
(VS100), and slowly acquired scattered features from the VT100, ANSI, and other
sources\cite{xtermfaq}. Thomas E.\ Dickey (the current maintainer of \Gls{ncurses}
and xterm) began working on XTerm in the mid-90s, and by 1996 had added the
\texttt{decTerminalID} resource following the addition of much VT220 compatibility.

\textbf{FIXME keep goin'\ldots}

\subsection{The Curses API}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Wherein I throw shade at current terminal emulators}
\label{sec:termshade}
\textbf{FIXME FIXME FIXME}
graphs i want:
\begin{denseitemize}
\item{emulator performance as a function of size}
\item{emulator performance as a function of bandwidth--same color everywhere, but turn off elision}
\item{emulator performance as a function of color change--difference with color restored relative to previous}
\item{emulator performance as a function of glyph variation}
\item{some basic perf flame graphs}
\end{denseitemize}
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The Linux console}
The Linux console\footnote{The FreeBSD console is its own bag of wonders.} is
substantially different from the X and Wayland terminal emulators to which one
might be more accustomed\footnote{Muddying the issue is the fact that video
backends are sometimes described as consoles. The ``Linux console'' is a terminal
emulator running atop some video backend---on the x86, typically either VGA
Text Mode, or some trivial renderer atop a graphics-mode framebuffer
(e.\ g.\ EFIfb or vesafb.)}. Modern terminal emulators are generally more capable
than the Linux console in several ways:

\begin{denseitemize}
\item{While the Linux console accepts RGB specifiers, it downsamples them to
    far fewer colors.}
\item{Console font capabilities are extremely limited.}
\end{denseitemize}

Like any interface to a termios\cite{termios} implementation, the \texttt{IUTF8}
flag should be set (consult \texttt{stty}). This can be accomplished with the
\texttt{IUTF8} termios flag (or \texttt{stty iutf8} on the command line). This
is necessary for the terminal to interpret your output as multibyte UTF-8. The
keyboard driver ought be placed into UTF-8 mode using the \texttt{KDSKBMODE}
ioctl; the \texttt{kbd-mode} tool does this when invoked with \texttt{-u}.
This is necessary for character erase to function properly in cooked mode. Some
keyboards generate scancodes beyond the essential 128 characters, and these
should be mapped to their UTF-8 equivalents. This can be accomplished with
\texttt{dumpkeys | loadkeys --unicode}\footnote{If you've ever seen the script
\texttt{unicode\_start}, this is exactly what it does.}. This functionality has
been supported since Linux 2.6.4, released 2004-03-11, and is almost certainly
already being done in your environment.

Ensure, as always, that \texttt{LANG} is properly set, that your program
initializes the locale with \texttt{setlocale(3)}, and that \texttt{TERM} is
properly set (in this case, to one of the ``linux*'' variants).

\textbf{FIXME FIXME FIXME talk about console font}

Consult the \textit{The Linux Programmer's Manual} for more information,
particularly
\texttt{ioctl\_console(2)}\cite{ioctlconsole},
\texttt{ioctl\_tty(2)}\cite{ioctltty},
\texttt{termios(3)}\cite{termios},
\texttt{console\_codes(4)}\cite{consolecodes},
and
\texttt{charsets(7)}\cite{charsets7}.

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Unicode 13}
The Unicode Consortium has scheduled Unicode 13.0 for a March 2020 release.
Chapters 3 and most of Chapter 4 of the Core Specification are normative. The
remainder is informative. The Unicode Standard consists of the Core
Specification\cite{unicode13}, the \href{https://www.unicode.org/charts/}{code charts},
the \href{https://unicode.org/versions/Unicode13.0.0/#Unicode_Standard_Annexes_nb}{Unicode Standard Annexes},
and the \href{http://www.unicode.org/Public/13.0.0/}{Unicode Character Database (UCD)}.

\begin{table}[h]
\begin{center}
  \begin{tabular}{ |c|c| }
    \hline
    UAX \#9 & Unicode Bidirectional Algorithm \\
    \hline
    UTS \#10 & Unicode Collation Algorithm \\
    \hline
    UAX \#11 & East Asian Width \\
    \hline
    UAX \#14 & Unicode Line Breaking Algorithm \\
    \hline
    UAX \#15 & Unicode Normalization Forms \\
    \hline
    UAX \#24 & Unicode Script Property \\
    \hline
    UAX \#29 & Unicode Text Segmentation \\
    \hline
    UAX \#31 & Unicode Identifier and Pattern Syntax \\
    \hline
    UAX \#34 & Unicode Named Character Sequences \\
    \hline
    UAX \#38 & Unicode Han Database (Unihan) \\
    \hline
    UTS \#39 & Unicode Security Mechanisms \\
    \hline
    UAX \#41 & Common References for Unicode Standard Annexes \\
    \hline
    UAX \#42 & Unicode Character Database in XML \\
    \hline
    UAX \#44 & Unicode Character Database \\
    \hline
    UAX \#45 & U-Source Ideographs \\
    \hline
    UTS \#46 & Unicode IDNA Compatibility Processing \\
    \hline
    UAX \#50 & Unicode Vertical Text Layout \\
    \hline
    UTS \#51 & Unicode Emoji \\
    \hline
  \end{tabular}
\caption{Unicode 13.0.0 Standard Annexes and Synchronized Technical Standards.}
\end{center}
\end{table}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Notcurses header files}
\subsection{The \texttt{notcurses.h} header}
\bgroup
\inputminted[linenos,breaklines=true]{C}{code/notcurses.h}
\egroup

\subsection{The \texttt{nckeys.h} header}
\bgroup
\inputminted[linenos,breaklines=true]{C}{code/nckeys.h}
\egroup

\end{appendices}
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\glsaddallunused
\printglossary[title={Glossary of terms}]
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\addcontentsline{toc}{section}{References}
\printbibliography
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
%\vfill
%\begin{center}
%\includegraphics[width=.4\linewidth]{../common/dsscaw-purp-scaled.png}
%\includegraphics[width=.5\linewidth]{../common/south.png}
%\end{center}
%\vfill
\end{document}
