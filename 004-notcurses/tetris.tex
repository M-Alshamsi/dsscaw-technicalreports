\subsection{Example: let's rip off tetris}
\label{sec:casestudy}
Recall our exploration of tetriminos from Chapter~\ref{sec:simpleloop}. We
know enough now to turn this into an actual game of terminal Tetris\footnote{There
are a great many distinct Tetris implementations. We'll aim for loose
conformance to the NES version as published by Nintendo of America, because
I'm old. See \url{https://tetris.wiki/Tetris_(NES,_Nintendo)}. I'm not going
to obsess over details, though.}. Our implementation is fewer than 200 lines
total, yet it unites most of the techniques introduced in the past few
chapters. For fun, we'll do this in \CC\footnote{LOL how often does one hear
that said?}, using Marek Habersack's \CC wrappers (installed with Notcurses).

Our \texttt{main()} will parse command line options, set up a \texttt{Tetris}
object appropriately, and watch for input. The \texttt{Tetris} object provides
a thread function \texttt{Ticker} which moves the current piece down according
to timer events (calling \texttt{StuckPiece} to determine if the piece has been
placed, in which case a new piece enters the playing area), and the necessary
interface for the input loop:

\begin{denseitemize}
\item{\texttt{MoveLeft()} (Listing~\ref{list:tetris-moveleft}) and \texttt{MoveRight()}
    (Listing~\ref{list:tetris-moveright}). These simply verify that the lateral
    move can be done, and then call \texttt{Plane::move()}.}
\item{\texttt{MoveDown()} (Listing~\ref{list:tetris-movedown}), which calls the same \texttt{StuckPiece()},}
\item{\texttt{Pause()}, and}
\item{\texttt{RotateCCw()} and \texttt{RotateCw()}, which verify that the rotation
      is possible, and then call \texttt{Plane::rotate\_cw()} or \texttt{Plane::rotate\_ccw()}.}
\end{denseitemize}

The general structure of our solution is thus:

\begin{denseitemize}
\item{A background is drawn onto the standard plane.}
\item{A new plane is created for the game area. Why make a new plane? Recall
    the beginning of Chapter~\ref{sec:planes}: \textit{we use a plane wherever we
    benefit from distinct state}. By keeping the game area on its own plane,
    we can trivially move it in response to terminal resizes, and likewise
    trivially test whether the current piece can move in a given direction.}
\item{Two tetrimino planes are created, one for the current piece, and one for
    the next piece. The current piece descends from the top of the game area.
    Upon reaching its final position, its plane is added to the game plane
    using \texttt{ncplane\_mergedown()}. The next piece is brought to the top
    of the game area, and the current piece is redrawn on its way to becoming
    the next piece.}
\item{We need no external state save the score and the order of pieces. The order
    of pieces is left up to the PRNG. We only need track the score and
    our four planes. The validity of a given movement can be checked entirely
    by reflection, using \texttt{ncplane\_at\_yx()}.}
\item{Our main thread loops on \texttt{Notcurses::getc()}, calling into the
    \texttt{Tetris} object. These calls will need to lock against the timer thread.}
\item{If \texttt{StuckPiece()} returns \texttt{true}, and the stuck piece
    is at the top of the playing area, the game is over.}
\end{denseitemize}

The playing area should not be visible while the game is paused, so whenever
the game is paused, we'll move the standard plane to the top of the z-axis. As
it is opaque and spans the visible area, this will hide the playing area. We'll
furthermore throw up a three-row plane centered on the screen; this plane will
contain a perimeter, and pulsing text reading ``Paused''. On an unpause event,
the attract plane is destroyed, and the standard plane moved back to the bottom
of the z-axis. Nothing else needs be touched, save inhibiting the operation
of \texttt{Ticker()}. This could be done any number of ways; we'll use a
condition variable plus a bit flag, checking it upon emerging from our timeout.

\begin{listing}[!htb]
\inputminted[]{C}{code-tetris/background.h}
\caption{Drawing the background and the gameplay plane.}
\label{list:tetris-background}
\end{listing}

Our resize logic is pretty simple: on a resize event, after verifying that the
new geometry is large enough to play on (if not, we pause the game), we must
redraw the background, move the playing area to the new bottom center of the
visible area, and move the current piece to its same location relative to the
playing area. If the game is already paused when we resize, we ought
additionally recenter the attract plane. This is about as trivial as resize
handling comes\footnote{Imagine that we sized the playing area according to the
visible area. This would require resizing the game board upon a terminal
resize, a decidedly messier affair. It's doable, of course---\textgreek{ἢ τὰν ἢ ἐπὶ τᾶς}.}.

Let's do some boring groundwork first. We'll need the official constants for
``gravity'', the level-dependent rate at which pieces fall
(Listing~\ref{list:tetris-gravity}). We can implement this as a
\texttt{constexpr} function (not that it's likely to be of any real advantage).

\begin{listing}[!htb]
\inputminted[]{C}{code-tetris/gravity.h}
\caption{Tetris gravity by level.}
\label{list:tetris-gravity}
\end{listing}

\begin{listing}[!htb]
\inputminted[]{C}{code-tetris/movedown.h}
\caption{\texttt{Tetris::MoveDown()}.}
\label{list:tetris-movedown}
\end{listing}

\begin{listing}[!htb]
\inputminted[]{C}{code-tetris/moveleft.h}
\caption{\texttt{Tetris::MoveLeft()}.}
\label{list:tetris-moveleft}
\end{listing}

\begin{listing}[!htb]
\inputminted[]{C}{code-tetris/moveright.h}
\caption{\texttt{Tetris::MoveRight()}.}
\label{list:tetris-moveright}
\end{listing}

\begin{listing}[!htb]
\inputminted[]{C}{code-tetris/rotate.h}
\caption{Tetris rotation functions.}
\label{list:tetris-rotate}
\end{listing}

\begin{listing}[!htb]
\inputminted[]{C}{code-tetris/newpiece.h}
\inputminted[]{C}{code-tetris/stuck.h}
\caption{\texttt{Tetris::NewPiece()} and \texttt{Tetris::PieceStick()}.}
\label{list:tetris-newpiece}
\end{listing}

\begin{listing}[!htb]
\inputminted[]{C}{code-tetris/ticker.h}
\caption{\texttt{Tetris::Ticker()}.}
\label{list:tetris-ticker}
\end{listing}

\begin{listing}[!htb]
\inputminted[]{C}{code-tetris/main.cpp}
\caption{\texttt{main()} for our Tetris ripoff.}
\label{list:tetris-main}
\end{listing}

\textbf{FIXME FIXME FIXME}
